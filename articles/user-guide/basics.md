---
title: Q# Básicos
description: 'Conceitos básicos de Q #'
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
ms.openlocfilehash: e77b52d1a6eb7e2f62ab12dedd75d00ac8fec4be
ms.sourcegitcommit: a35498492044be4018b4d1b3b611d70a20e77ecc
ms.translationtype: MT
ms.contentlocale: pt-PT
ms.lasthandoff: 06/03/2020
ms.locfileid: "84327327"
---
# <a name="q-basics"></a><span data-ttu-id="a7ec5-103">Q# Básicos</span><span class="sxs-lookup"><span data-stu-id="a7ec5-103">Q# Basics</span></span>

<span data-ttu-id="a7ec5-104">Nesta secção apresentamos uma breve introdução aos blocos básicos de construção de Q#.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-104">In this section we present a brief introduction to the basic building blocks of Q#.</span></span>

<span data-ttu-id="a7ec5-105">Para uma visão geral rápida do que é Q# e onde se enquadra como componente fundamental do Kit de Desenvolvimento Quântico, pode verificar [o que é Q#?](xref:microsoft.quantum.overview.q-sharp)</span><span class="sxs-lookup"><span data-stu-id="a7ec5-105">For a quick overview of what Q# is and where it fits in as a fundamental component of the Quantum Development Kit, you can check out [What is Q#?](xref:microsoft.quantum.overview.q-sharp).</span></span> 

## <a name="what-is-a-quantum-program"></a><span data-ttu-id="a7ec5-106">O que é um programa quântico?</span><span class="sxs-lookup"><span data-stu-id="a7ec5-106">What is a quantum program?</span></span>

<span data-ttu-id="a7ec5-107">Do ponto de vista técnico, um programa quântico pode ser visto como um conjunto particular de sub-rotinas clássicas que, quando chamados, realizam certas operações num sistema quântico.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-107">From a technical perspective, a quantum program can be seen as a particular set of classical subroutines which, when called, perform certain operations on a quantum system.</span></span>
<span data-ttu-id="a7ec5-108">Uma consequência importante dessa visão é que um programa escrito em Q# não modela diretamente os qubits, mas descreve como um computador de controlo clássico interage com esses qubits.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-108">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="a7ec5-109">Por design, Q# assim não define estados quânticos ou outras propriedades da mecânica quântica diretamente.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-109">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly.</span></span>
<span data-ttu-id="a7ec5-110">Por exemplo, considere o estado $\ket{+} = \left {0} (\ket + \ket {1} \right) / \sqrt {2} $ discutido no guia quantum [Computing Concepts.](xref:microsoft.quantum.concepts.intro)</span><span class="sxs-lookup"><span data-stu-id="a7ec5-110">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="a7ec5-111">Para preparar este estado em Q#, usamos os fatos que os qubits são inicializados no estado de $\ket {0} $, e que $\ket{+} = H\ket {0} $, onde $H$ é a transformação Hadamard, implementada pela `H` [operação](xref:microsoft.quantum.intrínseco.h):</span><span class="sxs-lookup"><span data-stu-id="a7ec5-111">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform, implemented by the [`H` operation](](xref:microsoft.quantum.intrinsic.h):</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0⟩.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0⟩ = |+⟩, as we wanted.
}
```

## <a name="quantum-states-in-q"></a><span data-ttu-id="a7ec5-112">Estados quânticos em Q #</span><span class="sxs-lookup"><span data-stu-id="a7ec5-112">Quantum states in Q#</span></span>

<span data-ttu-id="a7ec5-113">Importante, ao escrever o programa acima, não nos referimos explicitamente ao estado dentro de Q#, mas sim descrever como o estado foi *transformado* pelo nosso programa.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-113">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="a7ec5-114">Isto permite-nos ser totalmente agnósticos sobre o que *é* um estado quântico em cada máquina-alvo, que pode ter interpretações diferentes dependendo da máquina.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-114">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="a7ec5-115">Um programa Q# não tem capacidade de introspeção no estado de um qubit.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-115">A Q# program has no ability to introspect into the state of a qubit.</span></span>
<span data-ttu-id="a7ec5-116">Em vez disso, um programa pode chamar operações como [`Measure`](xref:microsoft.quantum.intrinsic.measure) aprender informações de um qubit, e ligar operações como [`X`](xref:microsoft.quantum.intrinsic.x) e agir sobre o estado de um [`H`](xref:microsoft.quantum.intrinsic.h) qubit.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-116">Rather, a program can call operations such as [`Measure`](xref:microsoft.quantum.intrinsic.measure) to learn information from a qubit, and call operations such as [`X`](xref:microsoft.quantum.intrinsic.x) and [`H`](xref:microsoft.quantum.intrinsic.h) to act on the state of a qubit.</span></span>
<span data-ttu-id="a7ec5-117">O que estas operações realmente *fazem* é apenas feito concreto pela máquina-alvo que usamos para executar o programa Q# específico.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-117">What these operations actually *do* is only made concrete by the target machine we use to run the particular Q# program.</span></span>
<span data-ttu-id="a7ec5-118">Por exemplo, se executar o programa no nosso [simulador de estado completo,](xref:microsoft.quantum.machines.full-state-simulator)o simulador realizará as operações matemáticas correspondentes ao sistema quântico simulado.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-118">For example, if running the program on our [full-state simulator](xref:microsoft.quantum.machines.full-state-simulator), the simulator will perform the corresponding mathematical operations to the simulated quantum system.</span></span>
<span data-ttu-id="a7ec5-119">Mas olhando para o futuro, quando a máquina-alvo é um verdadeiro computador quântico, chamar tais operações em Q# irá direcionar o computador quântico para realizar as operações *reais* correspondentes no sistema quântico *real* (por exemplo, pulsos laser precisamente cronometrado).</span><span class="sxs-lookup"><span data-stu-id="a7ec5-119">But looking toward the future, when the target machine is a real quantum computer, calling such operations in Q# will direct the quantum computer to perform the corresponding *real* operations on the *real* quantum system (e.g. precisely timed laser pulses).</span></span>

<span data-ttu-id="a7ec5-120">Um programa Q# recombina estas operações tal como definido por uma máquina-alvo para criar novas operações de alto nível para expressar a computação quântica.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-120">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="a7ec5-121">Desta forma, q# torna fácil expressar a lógica subjacente a algoritmos quânticos e híbridos quânticos-clássicos, ao mesmo tempo que é geral no que diz respeito à estrutura de uma máquina-alvo ou simulador.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-121">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum–classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="a7ec5-122">Q# operações e funções</span><span class="sxs-lookup"><span data-stu-id="a7ec5-122">Q# operations and functions</span></span>

<span data-ttu-id="a7ec5-123">Concretamente, um programa Q# é composto por *operações,* funções e quaisquer tipos *definidos*pelo utilizador.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-123">Concretely, a Q# program is comprised of *operations*, *functions*, and any user-defined types.</span></span> 

<span data-ttu-id="a7ec5-124">As operações são usadas para descrever as transformações dos sistemas quânticos e são o bloco de construção mais básico dos programas Q#.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-124">Operations are used to describe the transformations of quantum systems and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="a7ec5-125">Cada operação definida em Q# pode então chamar qualquer número de outras operações.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-125">Each operation defined in Q# may then call any number of other operations.</span></span>

<span data-ttu-id="a7ec5-126">Ao contrário das operações, as funções são usadas para descrever comportamentos clássicos puramente *deterministas* e não têm quaisquer efeitos além de calcular valores clássicos.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-126">In contrast to operations, functions are used to describe purely *deterministic* classical behavior and do not have any effects besides computing classical values.</span></span> <span data-ttu-id="a7ec5-127">Por exemplo, suponha que gostaríamos de medir os nossos qubits no final de um programa, e adicionar os resultados da medição a uma matriz.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-127">For example, suppose we would like to measure our qubits at the end of a program, and add the measurement results to an array.</span></span>
<span data-ttu-id="a7ec5-128">Neste `Measure` caso, é uma *operação* que instrui a máquina-alvo a efetuar uma medição dos qubits (reais ou simulados) e o processo clássico de adição dos resultados devolvidos a uma matriz será tratado por *funções*.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-128">In this case `Measure` is an *operation* which instructs the target machine to perform a measurement on the (real or simulated) qubits, and the classical process of adding the returned results to an array will be handled by *functions*.</span></span>

<span data-ttu-id="a7ec5-129">Em conjunto, as operações e funções são referidas como *callables,* e a sua estrutura e comportamento subjacentes é introduzida na página [Operações e Funções na página Q#.](xref:microsoft.quantum.guide.operationsfunctions)</span><span class="sxs-lookup"><span data-stu-id="a7ec5-129">Together, operations and functions are referred to as *callables*, and their underlying structure and behavior is introduced on the [Operations and Functions in Q#](xref:microsoft.quantum.guide.operationsfunctions) page.</span></span>


## <a name="q-syntax-overview"></a><span data-ttu-id="a7ec5-130">Visão geral da sintaxe Q#</span><span class="sxs-lookup"><span data-stu-id="a7ec5-130">Q# syntax overview</span></span>

<span data-ttu-id="a7ec5-131">A sintaxe de uma linguagem descreve as diferentes combinações de símbolos que formam um programa sintáticamente correto.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-131">The syntax of a language describes the different combinations of symbols that form a syntactically correct program.</span></span>
<span data-ttu-id="a7ec5-132">Em Q# podemos classificar os elementos da sua sintaxe em três grupos diferentes: tipos, expressões e declarações.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-132">In Q# we can classify the elements of its syntax in three different groups: types, expressions and statements.</span></span>

### <a name="types"></a><span data-ttu-id="a7ec5-133">Tipos</span><span class="sxs-lookup"><span data-stu-id="a7ec5-133">Types</span></span>
<span data-ttu-id="a7ec5-134">Q# é uma linguagem fortemente dactilografada, de modo que o uso cuidadoso de tipos pode ajudar o compilador a fornecer garantias fortes sobre os programas Q# no momento da compilação.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-134">Q# is a strongly-typed language, such that careful use of types can help the compiler provide strong guarantees about Q# programs at compile time.</span></span>
<span data-ttu-id="a7ec5-135">Para além dos tipos primitivos integrados standard e específicos quânticos (por `Int` `Bool` exemplo, `Qubit` , e , `Result` Q# fornece suporte para tipos definidos pelo utilizador.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-135">In addition to standard and quantum-specific built-in primitive types (e.g. `Int`, `Bool`, `Qubit`, and `Result`), Q# provides support for user-defined types.</span></span>
<span data-ttu-id="a7ec5-136">Todos os vários tipos primitivos de Q#são descritos na página Tipos na página [Q#,](xref:microsoft.quantum.guide.types) juntamente com detalhes sobre os tipos de matriz e tuple, bem como como definir novos tipos dentro de um ficheiro Q#.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-136">All of Q#'s various primitive types are described on the [Types in Q#](xref:microsoft.quantum.guide.types) page, along with details on array and tuple types, as well as how to define new types within a Q# file.</span></span>

### <a name="expressions"></a><span data-ttu-id="a7ec5-137">Expressions (Expressões)</span><span class="sxs-lookup"><span data-stu-id="a7ec5-137">Expressions</span></span>
<span data-ttu-id="a7ec5-138">Uma expressão numa linguagem de programação é uma combinação de uma ou mais constantes, variáveis, operadores e funções que a linguagem de programação interpreta e avalia a um valor específico.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-138">An expression in a programming language is a combination of one or more constants, variables, operators, and functions that the programming language interprets and evaluates to a specific value.</span></span>
<span data-ttu-id="a7ec5-139">Mais simplesmente, para cada tipo de linguagem, expressões desse tipo podem ser *literais* ou símbolos ligados a um valor desse tipo.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-139">Most simply, for every type in a language, expressions of that type can be either *literals* or symbols bound to a value of that type.</span></span>
<span data-ttu-id="a7ec5-140">Por exemplo, `5` é um `Int` literal (portanto, também uma expressão do `Int` tipo), e se o símbolo está `count` ligado ao valor `5` inteiro, então `count` é também uma expressão inteiro.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-140">For example, `5` is an `Int` literal (thus also an expression of type `Int`), and if the symbol `count` is bound to the integer value `5`, then `count` is also an integer expression.</span></span>

<span data-ttu-id="a7ec5-141">Além disso, uma expressão pode consistir em outras expressões combinadas com certos operadores.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-141">Additionally, an expression can consist of other expressions combined with certain operators.</span></span>
<span data-ttu-id="a7ec5-142">Daí outro exemplo de uma `Int` expressão que avalia `5` `2+3` é.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-142">Hence another example of an `Int` expression which evaluates to `5` is `2+3`.</span></span>

<span data-ttu-id="a7ec5-143">As possíveis expressões de tipos em Q#, bem como os operadores compatíveis que podem ser usados para forme-los, são detalhados na página Tipo Expressões na página [Q#.](xref:microsoft.quantum.guide.expressions)</span><span class="sxs-lookup"><span data-stu-id="a7ec5-143">The possible expressions of types in Q#, as well as the compatible operators that can be used to form them, are detailed on the [Type Expressions in Q#](xref:microsoft.quantum.guide.expressions) page.</span></span> 

### <a name="statements"></a><span data-ttu-id="a7ec5-144">Instruções</span><span class="sxs-lookup"><span data-stu-id="a7ec5-144">Statements</span></span> 
<span data-ttu-id="a7ec5-145">Uma declaração é uma unidade sintática de uma linguagem de programação imperativa que expressa alguma ação a ser realizada. As declarações contrastam com expressões em que as declarações não devolvem resultados e são executadas apenas pelos seus efeitos colaterais, enquanto as expressões devolvem sempre um resultado e muitas vezes não têm efeitos colaterais.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-145">A statement is a syntactic unit of an imperative programming language that expresses some action to be carried out. Statements contrast with expressions in that statements do not return results and are executed solely for their side effects, while expressions always return a result and often do not have side effects at all.</span></span>
<span data-ttu-id="a7ec5-146">Esta distinção é frequentemente observada na redação: uma expressão é avaliada, enquanto uma declaração é executada.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-146">This distinction is frequently observed in wording: an expression is evaluated, whereas a statement is executed.</span></span>

<span data-ttu-id="a7ec5-147">Um exemplo muito básico de uma declaração em Q# é atribuir um símbolo a uma expressão:</span><span class="sxs-lookup"><span data-stu-id="a7ec5-147">A very basic example of a statement in Q# is assigning a symbol to an expression:</span></span>
```qsharp
let count = 5;
```

<span data-ttu-id="a7ec5-148">Um exemplo um pouco mais interessante é a `for` afirmação que suporta a iteração e inclui um *bloco de declaração.*</span><span class="sxs-lookup"><span data-stu-id="a7ec5-148">A slightly more interesting example is the `for` statement which supports iteration and includes a *statement block*.</span></span>
<span data-ttu-id="a7ec5-149">Suponha que `qubits` seja o símbolo ligado a um registo de qubits (tecnicamente de `Qubit[]` tipo, isto é, uma matriz de `Qubit` tipos).</span><span class="sxs-lookup"><span data-stu-id="a7ec5-149">Suppose `qubits` is the symbol bound to a register of qubits (technically of type `Qubit[]`, i.e. an array of `Qubit` types).</span></span> <span data-ttu-id="a7ec5-150">Então</span><span class="sxs-lookup"><span data-stu-id="a7ec5-150">Then</span></span>
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
<span data-ttu-id="a7ec5-151">é uma declaração que itera sobre cada qubit no registo, realizando a `H` operação em cada um.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-151">is a statement which iterates over each qubit in the register, performing the `H` operation on each.</span></span> <span data-ttu-id="a7ec5-152">Note que `H(qubit);` esta é uma afirmação em si mesma também.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-152">Note that `H(qubit);` is a statement in itself as well.</span></span>

<span data-ttu-id="a7ec5-153">De facto, qualquer expressão de chamada do tipo `Unit` (os calíveis que não devolvem nenhuma informação) pode ser usada como declaração.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-153">In fact, any call expression of type `Unit` (those callables that do not return any information) may be used as a statement.</span></span>
<span data-ttu-id="a7ec5-154">Isto é principalmente útil quando se chama operações em qubits que regressam `Unit` porque o objetivo da declaração é modificar o estado quântico implícito.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-154">This is primarily of use when calling operations on qubits that return `Unit` because the purpose of the statement is to modify the implicit quantum state.</span></span>
<span data-ttu-id="a7ec5-155">As declarações de avaliação de expressão requerem um ponto de terminação.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-155">Expression evaluation statements require a terminating semicolon.</span></span>

<span data-ttu-id="a7ec5-156">Quase todos os aspetos de um programa Q# são construídos usando declarações, por isso nenhuma página poderia abranger toda a informação que lhes diz respeito.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-156">Nearly every aspect of a Q# program is built using statements, so no single page could encompass all the information relating to them.</span></span>
<span data-ttu-id="a7ec5-157">No entanto, a sua estrutura lexical e formatação são descritas na página [Q# Estrutura de Ficheiros,](xref:microsoft.quantum.guide.filestructure) atribuição de ligação de símbolos e âmbito [em Variáveis em Q#](xref:microsoft.quantum.guide.variables), e ciclos de fluxo de controlo tais como `for` no Control Flow in [Q#](xref:microsoft.quantum.guide.controlflow).</span><span class="sxs-lookup"><span data-stu-id="a7ec5-157">However, their lexical structure and formatting is described on the [Q# File Structure](xref:microsoft.quantum.guide.filestructure) page, symbol binding assignment and scope at [Variables in Q#](xref:microsoft.quantum.guide.variables), and control flow loops such as `for` at [Control Flow in Q#](xref:microsoft.quantum.guide.controlflow).</span></span>

## <a name="next-steps"></a><span data-ttu-id="a7ec5-158">Próximos passos</span><span class="sxs-lookup"><span data-stu-id="a7ec5-158">Next steps</span></span>
<span data-ttu-id="a7ec5-159">Ao longo do resto deste guia, vamos mostrar-lhe como usar q# para construir programas quânticos complexos através dos blocos básicos de construção de operações, funções e tipos.</span><span class="sxs-lookup"><span data-stu-id="a7ec5-159">Throughout the rest of this guide, we will show you how to use Q# to construct complex quantum programs through the basic building blocks of operations, functions, and types.</span></span>

<span data-ttu-id="a7ec5-160">Para começar, pode começar a aprender sobre [tipos em Q#](xref:microsoft.quantum.guide.types).</span><span class="sxs-lookup"><span data-stu-id="a7ec5-160">To get started, you can start learning about [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

<span data-ttu-id="a7ec5-161">Se está interessado em aprender mais sobre as fundações e motivação por trás da Q#, confira [por que precisamos de Q#?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/)</span><span class="sxs-lookup"><span data-stu-id="a7ec5-161">If you are interested in learning more about the foundations and motivation behind Q#, check out [Why do we need Q#?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span></span>
