---
title: O qubit na computação quântica
description: Conheça os qubits, a unidade fundamental de informação na computação quântica.
author: QuantumWriter
uid: microsoft.quantum.concepts.qubit
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
no-loc:
- $
- $
- '\cdots'
- bmatrix
- '\ddots'
- '\equiv'
- '\sum'
- '\begin'
- '\end'
- '\sqrt'
- '\otimes'
- '{'
- '}'
- '\text'
- '\phi'
- '\kappa'
- '\psi'
- '\alpha'
- '\beta'
- '\gamma'
- '\delta'
- '\omega'
- '\bra'
- '\ket'
- '\boldone'
- '\\\\'
- '\\'
- =
- '\frac'
- '\text'
- '\mapsto'
- '\dagger'
- '\to'
- "\begin{cases}"
- "\end{cases}"
- '\operatorname'
- '\braket'
- '\id'
- '\expect'
- '\defeq'
- '\variance'
- '\dd'
- '&'
- "\begin{align}"
- "\end{align}"
- '\Lambda'
- '\lambda'
- '\Omega'
- '\mathrm'
- '\left'
- '\right'
- '\qquad'
- '\times'
- '\big'
- '\langle'
- '\rangle'
- '\bigg'
- '\Big'
- '|'
- '\mathbb'
- '\vec'
- '\in'
- '\texttt'
- '\ne'
- <
- '>'
- '\leq'
- '\geq'
- ~~
- "~"
ms.openlocfilehash: 833c9649b7fbcf8b9fde62c37246b9345fe59a92
ms.sourcegitcommit: e23178d32b316d05784a02ba3cd6166dad177e89
ms.translationtype: MT
ms.contentlocale: pt-PT
ms.lasthandoff: 06/09/2020
ms.locfileid: "84630344"
---
# <a name="the-qubit"></a><span data-ttu-id="fd286-103">O Qubit</span><span class="sxs-lookup"><span data-stu-id="fd286-103">The Qubit</span></span>

<span data-ttu-id="fd286-104">Assim como os bits são o objeto fundamental da informação na computação clássica, [*os qubits*](https://en.wikipedia.org/wiki/Qubit) (bits quânticos) são o objeto fundamental da informação na computação quântica.</span><span class="sxs-lookup"><span data-stu-id="fd286-104">Just as bits are the fundamental object of information in classical computing, [*qubits*](https://en.wikipedia.org/wiki/Qubit) (quantum bits) are the fundamental object of information in quantum computing.</span></span>  <span data-ttu-id="fd286-105">Para compreender esta correspondência, vejamos o exemplo mais simples: um único qubit.</span><span class="sxs-lookup"><span data-stu-id="fd286-105">To understand this correspondence, let's look at the simplest example: a single qubit.</span></span>

## <a name="representing-a-qubit"></a><span data-ttu-id="fd286-106">Representando um Qubit</span><span class="sxs-lookup"><span data-stu-id="fd286-106">Representing a Qubit</span></span>

<span data-ttu-id="fd286-107">Enquanto um pouco, ou dígito binário, pode ter valor de $0 $ ou $1, $ um qubit pode ter um valor que é um destes ou uma superposição quântica de $0 $ e $1 $ .</span><span class="sxs-lookup"><span data-stu-id="fd286-107">While a bit, or binary digit, can have value either $0$ or $1$, a qubit can have a value that is either of these or a quantum superposition of $0$ and $1$.</span></span>

<span data-ttu-id="fd286-108">O estado de um único qubit pode ser descrito por um vetor de coluna bidimensional de norma unitária, ou seja, a magnitude ao quadrado das suas entradas deve ser de $1 $ .</span><span class="sxs-lookup"><span data-stu-id="fd286-108">The state of a single qubit can be described by a two-dimensional column vector of unit norm, that is, the magnitude squared of its entries must sum to $1$.</span></span> <span data-ttu-id="fd286-109">Este vetor, chamado vetor de estado quântico, contém toda a informação necessária para descrever o sistema quântico de um qubit, assim como um único bit contém toda a informação necessária para descrever o estado de uma variável binária.</span><span class="sxs-lookup"><span data-stu-id="fd286-109">This vector, called the quantum state vector, holds all the information needed to describe the one-qubit quantum system just as a single bit holds all of the information needed to describe the state of a binary variable.</span></span>

<span data-ttu-id="fd286-110">Qualquer vetor de coluna bidimensional de números reais ou complexos com norma $1 $ representa um possível estado quântico detido por um qubit.</span><span class="sxs-lookup"><span data-stu-id="fd286-110">Any two-dimensional column vector of real or complex numbers with norm $1$ represents a possible quantum state held by a qubit.</span></span> <span data-ttu-id="fd286-111">Assim, $\begin\ bmatrix } \alpha \\ \\ \beta \end$ bmatrix } representa um estado qubit se $\alpha $ e $\beta $ são números complexos que satisfazem $\alpha | ^2 + \beta | ^2 = 1 $ .</span><span class="sxs-lookup"><span data-stu-id="fd286-111">Thus $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ represents a qubit state if $\alpha$ and $\beta$ are complex numbers satisfying $|\alpha|^2 + |\beta|^2 = 1$.</span></span> <span data-ttu-id="fd286-112">Alguns exemplos de vetores de estado quântico válidos que representam qubits incluem</span><span class="sxs-lookup"><span data-stu-id="fd286-112">Some examples of valid quantum state vectors representing qubits include</span></span>

<span data-ttu-id="fd286-113">$$\begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } , \start{ bmatrix } \\ \\ 0 1 \end{ bmatrix } , \start{ bmatrix } \frac{1 } {\sqrt{2 } } \\ \\ \frac{1 } {\sqrt{2 } } \end{ bmatrix } bmatrix } } {\sqrt{2 } } \\ \\ \frac { -1 } {\sqrt{2 } } \end{ , bmatrix } \text and { }\begin{ bmatrix } \frac{1 } {\sqrt{2 } } \\ \\ \frac{i } {\sqrt{2 } } \end{ bmatrix } .$$</span><span class="sxs-lookup"><span data-stu-id="fd286-113">$$\begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \begin{bmatrix} 0 \\\\  1 \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{1}{\sqrt{2}} \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{-1}{\sqrt{2}} \end{bmatrix}, \text{ and }\begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{i}{\sqrt{2}} \end{bmatrix}.$$</span></span>

<span data-ttu-id="fd286-114">Os vetores de estado quântico $\begin{ bmatrix } \\ \\ 10 \end{ bmatrix } $ e $\begin{ bmatrix } \\ \\ 0 1 \end$ bmatrix } assumem um papel especial.</span><span class="sxs-lookup"><span data-stu-id="fd286-114">The quantum state vectors $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ and $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$ take a special role.</span></span> <span data-ttu-id="fd286-115">Estes dois vetores formam uma base para o espaço vetorial que descreve o estado do qubit.</span><span class="sxs-lookup"><span data-stu-id="fd286-115">These two vectors form a basis for the vector space that describes the qubit's state.</span></span> <span data-ttu-id="fd286-116">Isto significa que qualquer vetor de estado quântico pode ser escrito como uma soma destes vetores de base.</span><span class="sxs-lookup"><span data-stu-id="fd286-116">This means that any quantum state vector can be written as a sum of these basis vectors.</span></span> <span data-ttu-id="fd286-117">Especificamente, o vetor $\begin{ bmatrix } x \\ \\ y \end$ bmatrix } pode ser escrito como $x \start{ bmatrix } \\ \\ 1 0 \end{ bmatrix } + y \begin{ bmatrix } \\ \\ 0 1 \end{end{$. bmatrix }</span><span class="sxs-lookup"><span data-stu-id="fd286-117">Specifically, the vector $\begin{bmatrix} x \\\\  y \end{bmatrix}$ can be written as $x \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} + y \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="fd286-118">Embora qualquer rotação destes vetores sirva como uma base perfeitamente válida para o qubit, escolhemos privilegiar este, chamando-lhe a *base computacional.*</span><span class="sxs-lookup"><span data-stu-id="fd286-118">While any rotation of these vectors would serve as a perfectly valid basis for the qubit, we choose to privilege this one, by calling it the *computational basis*.</span></span>

<span data-ttu-id="fd286-119">Levamos estes dois estados quânticos para corresponder aos dois estados de um bit clássico, nomeadamente $0 $ e $1. $</span><span class="sxs-lookup"><span data-stu-id="fd286-119">We take these two quantum states to correspond to the two states of a classical bit, namely $0$ and $1$.</span></span> <span data-ttu-id="fd286-120">A convenção padrão é escolher</span><span class="sxs-lookup"><span data-stu-id="fd286-120">The standard convention is to choose</span></span>

<span data-ttu-id="fd286-121">$0 \equiv \start bmatrix } 1 \\ \\ 0 \end{, bmatrix } \qquad 1 \equiv \begin{ bmatrix } \\ \\ 0 1 \end{ bmatrix } ,$$</span><span class="sxs-lookup"><span data-stu-id="fd286-121">$$0\equiv \begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \qquad 1 \equiv \begin{bmatrix} 0 \\\\  1 \end{bmatrix},$$</span></span>

<span data-ttu-id="fd286-122">embora a escolha oposta poderia igualmente ser tomada.</span><span class="sxs-lookup"><span data-stu-id="fd286-122">although the opposite choice could equally well be taken.</span></span> <span data-ttu-id="fd286-123">Assim, do número infinito de possíveis vetores de estado quântico de um único qubit, apenas dois correspondem a estados de bits clássicos; todos os outros estados quânticos não.</span><span class="sxs-lookup"><span data-stu-id="fd286-123">Thus, out of the infinite number of possible single-qubit quantum state vectors, only two correspond to states of classical bits; all other quantum states do not.</span></span>

## <a name="measuring-a-qubit"></a><span data-ttu-id="fd286-124">Medindo um Qubit</span><span class="sxs-lookup"><span data-stu-id="fd286-124">Measuring a Qubit</span></span>

<span data-ttu-id="fd286-125">Agora que sabemos representar um qubit, podemos ganhar alguma intuição para o que estes Estados representam, discutindo o conceito de [*medição.*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics)</span><span class="sxs-lookup"><span data-stu-id="fd286-125">Now that we know how to represent a qubit, we can gain some intuition for what these states represent by discussing the concept of [*measurement*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics).</span></span> <span data-ttu-id="fd286-126">Uma medição corresponde à ideia informal de "olhar" para um qubit, que imediatamente colapsa o estado quântico para um dos dois estados clássicos $\begin{ bmatrix } \\ \\ 10 \end$ bmatrix } ou $\start bmatrix } 0 \\ \\ 1 \end{ bmatrix } $.</span><span class="sxs-lookup"><span data-stu-id="fd286-126">A measurement corresponds to the informal idea of “looking” at a qubit, which immediately collapses the quantum state to one of the two classical states  $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ or  $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="fd286-127">Quando um qubit dado pelo vetor de estado quântico $\begin\ bmatrix } \alpha \\ \\ \beta \end$ bmatrix } é medido, obtemos o resultado $0 $ com probabilidade $\alpha | ^2 $ e o resultado $1 $ com probabilidade $\beta | ^2 $ .</span><span class="sxs-lookup"><span data-stu-id="fd286-127">When a qubit given by the quantum state vector  $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ is measured, we obtain the outcome $0$ with probability $|\alpha|^2$ and the outcome $1$  with probability $|\beta|^2$.</span></span> <span data-ttu-id="fd286-128">No resultado $0, $ o novo estado do qubit é $\start{ bmatrix } 10 \\ \\ \end... bmatrix } $; no resultado $1 o seu estado é $ $\begin{ bmatrix } \\ \\ 0 1 \end{ bmatrix } $.</span><span class="sxs-lookup"><span data-stu-id="fd286-128">On outcome $0$, the qubit's new state is $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$; on outcome $1$ its state is $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="fd286-129">Note que estas probabilidades resumem até $1 $ devido à condição de normalização $\alpha | ^2 + \beta | ^2 = 1 $ .</span><span class="sxs-lookup"><span data-stu-id="fd286-129">Note that these probabilities sum up to $1$ because of the normalization condition $|\alpha|^2 + |\beta|^2 = 1$.</span></span>

<span data-ttu-id="fd286-130">As propriedades da medição também significam que o sinal geral do vetor do estado quântico é irrelevante.</span><span class="sxs-lookup"><span data-stu-id="fd286-130">The properties of measurement also mean that the overall sign of the quantum state vector is irrelevant.</span></span> <span data-ttu-id="fd286-131">A negação de um vetor é equivalente a $\alpha \rightarrow -\alpha $ e $\beta \rightarrow -\beta $ .</span><span class="sxs-lookup"><span data-stu-id="fd286-131">Negating a vector is equivalent to $\alpha \rightarrow -\alpha$ and $\beta \rightarrow -\beta$.</span></span> <span data-ttu-id="fd286-132">Porque a probabilidade de medir $0 $ e $1 $ depende da magnitude ao quadrado dos termos, inserir tais sinais não altera as probabilidades.</span><span class="sxs-lookup"><span data-stu-id="fd286-132">Because the probability of measuring $0$ and $1$ depends on the magnitude squared of the terms, inserting such signs does not change the probabilities whatsoever.</span></span> <span data-ttu-id="fd286-133">Tais fases são geralmente chamadas [ \`\` *fases globais*''](https://en.wikipedia.org/wiki/Phase_factor) e, de um modo geral, podem ser da forma $e^{i \phi } $ em vez de apenas $\pm 1 $ .</span><span class="sxs-lookup"><span data-stu-id="fd286-133">Such phases are commonly called [\`\`*global phases*''](https://en.wikipedia.org/wiki/Phase_factor) and more generally can be of the form $e^{i \phi}$ rather than just $\pm 1$.</span></span>

<span data-ttu-id="fd286-134">Uma propriedade importante final da medição é que não danifica necessariamente todos os vetores do estado quântico.</span><span class="sxs-lookup"><span data-stu-id="fd286-134">A final important property of measurement is that it does not necessarily damage all quantum state vectors.</span></span> <span data-ttu-id="fd286-135">Se começarmos com um qubit no estado $\begin{ bmatrix } \\ \\ 10 \end, bmatrix } o que corresponde ao estado clássico $0, $ medir este estado sempre renderá o resultado $0 $ e deixará o estado quântico inalterado.</span><span class="sxs-lookup"><span data-stu-id="fd286-135">If we start with a qubit in the state $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$, which corresponds to the classical state $0$, measuring this state will always yield the outcome $0$ and leave the quantum state unchanged.</span></span> <span data-ttu-id="fd286-136">Neste sentido, se tivermos apenas bits clássicos (ou seja, qubits que são ou $\begin} bmatrix }1 \\ \\ 0 \end$ bmatrix } ou $\begin} bmatrix }0 \\ \\ 1 \end{ bmatrix } $) então a medição não danifica o sistema.</span><span class="sxs-lookup"><span data-stu-id="fd286-136">In this sense, if we only have classical bits (i.e., qubits that are either $\begin{bmatrix}1 \\\\  0 \end{bmatrix}$ or $\begin{bmatrix}0 \\\\  1 \end{bmatrix}$) then measurement does not damage the system.</span></span> <span data-ttu-id="fd286-137">Isto significa que podemos replicar dados clássicos e manipulá-lo num computador quântico, tal como se poderia fazer num computador clássico.</span><span class="sxs-lookup"><span data-stu-id="fd286-137">This means that we can replicate classical data and manipulate it on a quantum computer just as one could do on a classical computer.</span></span> <span data-ttu-id="fd286-138">A capacidade, no entanto, de armazenar informação em ambos os Estados ao mesmo tempo é o que eleva a computação quântica para além do que é possível clássicamente e rouba ainda mais computadores quânticos da capacidade de copiar dados quânticos indiscriminadamente, ver também [o teorema de não clonagem.](https://en.wikipedia.org/wiki/No-cloning_theorem)</span><span class="sxs-lookup"><span data-stu-id="fd286-138">The ability, however, to store information in both states at once is what elevates quantum computing beyond what is possible classically and further robs quantum computers of the ability to copy quantum data indiscriminately, see also [the no-cloning theorem](https://en.wikipedia.org/wiki/No-cloning_theorem).</span></span>

## <a name="visualizing-qubits-and-transformations-using-the-bloch-sphere"></a><span data-ttu-id="fd286-139">Visualização de Qubits e Transformações usando a Esfera bloch</span><span class="sxs-lookup"><span data-stu-id="fd286-139">Visualizing Qubits and Transformations using the Bloch Sphere</span></span>

<span data-ttu-id="fd286-140">Qubits também podem ser retratados em $3$D usando a representação da [*esfera bloch.*](https://en.wikipedia.org/wiki/Bloch_sphere)</span><span class="sxs-lookup"><span data-stu-id="fd286-140">Qubits may also be pictured in $3$D using the [*Bloch sphere*](https://en.wikipedia.org/wiki/Bloch_sphere) representation.</span></span>  <span data-ttu-id="fd286-141">A esfera bloch dá uma maneira de descrever um estado quântico de um único qubit (que é um vetor complexo bidimensional) como um vetor tridimensional de valor real.</span><span class="sxs-lookup"><span data-stu-id="fd286-141">The Bloch sphere gives a way of describing a single-qubit quantum state (which is a two-dimensional complex vector) as a three-dimensional real-valued vector.</span></span>  <span data-ttu-id="fd286-142">Isto é importante porque nos permite visualizar estados de um único qubit e, assim, desenvolver um raciocínio que pode ser inestimável na compreensão de estados multi-qubits (onde infelizmente a representação da esfera bloch se decompõe).</span><span class="sxs-lookup"><span data-stu-id="fd286-142">This is important because it allows us to visualize single-qubit states and thereby develop reasoning that can be invaluable in understanding multi-qubit states (where sadly the Bloch sphere representation breaks down).</span></span>  <span data-ttu-id="fd286-143">A esfera bloch pode ser visualizada da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="fd286-143">The Bloch sphere can be visualized as follows:</span></span>

<!--- ![](.\media\bloch.svg){ width=50% } --->
<span data-ttu-id="fd286-144">![Esfera de Bloch](~/media/concepts_bloch.png)</span><span class="sxs-lookup"><span data-stu-id="fd286-144">![Bloch sphere](~/media/concepts_bloch.png)</span></span>

<span data-ttu-id="fd286-145">As setas deste diagrama mostram a direção em que o vetor de estado quântico está apontando e cada transformação da seta pode ser considerada como uma rotação sobre um dos eixos cardeais.</span><span class="sxs-lookup"><span data-stu-id="fd286-145">The arrows in this diagram show the direction in which the quantum state vector is pointing and each transformation of the arrow can be thought of as a rotation about one of the cardinal axes.</span></span>
<span data-ttu-id="fd286-146">Ao pensar numa computação quântica como uma sequência de rotações é uma intuição poderosa, é um desafio usar esta intuição para desenhar e descrever algoritmos.</span><span class="sxs-lookup"><span data-stu-id="fd286-146">While thinking about a quantum computation as a sequence of rotations is a powerful intuition, it is challenging to use this intuition to design and describe algorithms.</span></span> <span data-ttu-id="fd286-147">Q# alivia esta questão fornecendo uma linguagem para descrever tais rotações.</span><span class="sxs-lookup"><span data-stu-id="fd286-147">Q# alleviates this issue by providing a language for describing such rotations.</span></span>

## <a name="single-qubit-operations"></a><span data-ttu-id="fd286-148">Operações single-Qubit</span><span class="sxs-lookup"><span data-stu-id="fd286-148">Single-Qubit Operations</span></span>

<span data-ttu-id="fd286-149">Os computadores quânticos processam dados aplicando um conjunto universal de portões quânticos que podem imitar qualquer rotação do vetor do estado quântico.</span><span class="sxs-lookup"><span data-stu-id="fd286-149">Quantum computers process data by applying a universal set of quantum gates that can emulate any rotation of the quantum state vector.</span></span>
<span data-ttu-id="fd286-150">Esta noção de universalidade é semelhante à noção de universalidade para a computação tradicional (ou seja, clássica) onde um conjunto de portão é considerado universal se cada transformação dos bits de entrada pode ser realizada usando um circuito de comprimento finito.</span><span class="sxs-lookup"><span data-stu-id="fd286-150">This notion of universality is akin to the notion of universality for traditional (i.e., classical) computing where a gate set is considered to be universal if every transformation of the input bits can be performed using a finite length circuit.</span></span>
<span data-ttu-id="fd286-151">Na computação quântica, as transformações válidas que nos são permitidas num qubit são transformações unitárias e medição.</span><span class="sxs-lookup"><span data-stu-id="fd286-151">In quantum computing, the valid transformations that we are allowed to perform on a qubit are unitary transformations and measurement.</span></span>
<span data-ttu-id="fd286-152">A *operação adjacente* ou a transposição complexa do conjugado é de importância crucial para a computação quântica porque é necessária para inverter as transformações quânticas.</span><span class="sxs-lookup"><span data-stu-id="fd286-152">The *adjoint operation* or the complex conjugate transpose is of crucial importance to quantum computing because it is needed to invert quantum transformations.</span></span>
<span data-ttu-id="fd286-153">Q# reflete isto fornecendo métodos para compilar automaticamente as sequências do portão para o seu adjacente, o que evita que o programador tenha de entregar códigos adjacentes em muitos casos.</span><span class="sxs-lookup"><span data-stu-id="fd286-153">Q# reflects this by providing methods to automatically compile gate sequences to their adjoint, which saves the programmer from having to hand code adjoints in many cases.</span></span> <span data-ttu-id="fd286-154">Um exemplo disso é mostrado abaixo:</span><span class="sxs-lookup"><span data-stu-id="fd286-154">An example of this is shown below:</span></span>

```qsharp
operation PrepareSuperposition(qubit : Qubit) : Unit
is Adj { // Auto-generate the adjoint of the operation
    H(qubit);
}
```

<span data-ttu-id="fd286-155">Embora este seja um exemplo trivial (como a <xref:microsoft.quantum.intrinsic.h> operação é auto-adjacente), você pode ver como isso se torna inestimável para operações de qubit mais complicadas.</span><span class="sxs-lookup"><span data-stu-id="fd286-155">Although this is a trivial example (as the <xref:microsoft.quantum.intrinsic.h[!OP.NO-LOC(> operation is self-adjoint), you can see how this becomes invaluable for more complicated qubit operations.</span></span>
<span data-ttu-id="fd286-156">Para mais informações, consulte [Operações e Funções.](xref:microsoft.quantum.guide.operationsfunctions)</span><span class="sxs-lookup"><span data-stu-id="fd286-156">For more information, see [Operations and Functions](xref:microsoft.quantum.guide.operationsfunctions).</span></span>

<span data-ttu-id="fd286-157">Há apenas quatro funções que mapeiam um pouco a um bit num computador clássico.</span><span class="sxs-lookup"><span data-stu-id="fd286-157">There are only four functions that map one bit to one bit on a classical computer.</span></span> <span data-ttu-id="fd286-158">Em contraste, há um número infinito de transformações unitárias num único qubit num computador quântico.</span><span class="sxs-lookup"><span data-stu-id="fd286-158">In contrast, there are an infinite number of unitary transformations on a single qubit on a quantum computer.</span></span> <span data-ttu-id="fd286-159">Portanto, nenhum conjunto finito de operações quânticas primitivas, [*chamados portões,*](https://en.wikipedia.org/wiki/Quantum_logic_gate)pode exatamente replicar o conjunto infinito de transformações unitárias permitidas na computação quântica.</span><span class="sxs-lookup"><span data-stu-id="fd286-159">Therefore, no finite set of primitive quantum operations, called [*gates*](https://en.wikipedia.org/wiki/Quantum_logic_gate), can exactly replicate the infinite set of unitary transformations allowed in quantum computing.</span></span> <span data-ttu-id="fd286-160">Isto significa que, ao contrário da computação clássica, é impossível para um computador quântico implementar todos os programas quânticos possíveis exatamente usando um número finito de portões.</span><span class="sxs-lookup"><span data-stu-id="fd286-160">This means, unlike classical computing, it is impossible for a quantum computer to implement every possible quantum program exactly using a finite number of gates.</span></span> <span data-ttu-id="fd286-161">Assim, os computadores quânticos não podem ser universais no mesmo sentido dos computadores clássicos.</span><span class="sxs-lookup"><span data-stu-id="fd286-161">Thus quantum computers cannot be universal in the same sense of classical computers.</span></span> <span data-ttu-id="fd286-162">Como resultado, quando dizemos que um conjunto de portas é *universal* para a computação quântica, na verdade, significamos algo ligeiramente mais fraco do que queremos dizer com a computação clássica.</span><span class="sxs-lookup"><span data-stu-id="fd286-162">As a result, when we say that a set of gates is *universal* for quantum computing we actually mean something slightly weaker than we mean with classical computing.</span></span>
<span data-ttu-id="fd286-163">Para a universalidade, exigimos que um computador quântico apenas *se aproxime* de cada matriz unitária dentro de um erro finito usando uma sequência de portão de comprimento finito.</span><span class="sxs-lookup"><span data-stu-id="fd286-163">For universality, we require that a quantum computer only *approximate* every unitary matrix within a finite error using a finite length gate sequence.</span></span>
<span data-ttu-id="fd286-164">Por outras palavras, um conjunto de portões é um conjunto de portão universal se qualquer transformação unitária pode ser escrita aproximadamente como um produto de portões deste conjunto.</span><span class="sxs-lookup"><span data-stu-id="fd286-164">In other words, a set of gates is a universal gate set if any unitary transformation can be approximately written as a product of gates from this set.</span></span> <span data-ttu-id="fd286-165">Exigimos que para qualquer erro prescrito vinculado, existam portões $G_{1, } G_{2 } ,\ldots, G_N $ do conjunto do portão de tal forma que</span><span class="sxs-lookup"><span data-stu-id="fd286-165">We require that for any prescribed error bound, there exist gates $G_{1}, G_{2},\ldots, G_N$ from the gate set such that</span></span>

<span data-ttu-id="fd286-166">$$ G_N G_{N-1 } \cdots G_2 G_1 \aprox. $$</span><span class="sxs-lookup"><span data-stu-id="fd286-166">$$ G_N G_{N-1} \cdots G_2 G_1 \approx U. $$</span></span>

<span data-ttu-id="fd286-167">Note que porque a convenção para a multiplicação da matriz é multiplicar da direita para a esquerda a primeira operação do portão nesta sequência, $G_N $ , é na verdade a última aplicada ao vetor de estado quântico.</span><span class="sxs-lookup"><span data-stu-id="fd286-167">Note that because the convention for matrix multiplication is to multiply from right to left the first gate operation in this sequence, $G_N$, is actually the last one applied to the quantum state vector.</span></span> <span data-ttu-id="fd286-168">Mais formalmente, dizemos que tal conjunto de porta é universal se para cada tolerância de erro $\epsilon>0 $ existe $G_1,\ldots, G_N $ tal que a distância entre $G_N\ldots G_1 $ e $U é no máximo $ $\epsilon $ .</span><span class="sxs-lookup"><span data-stu-id="fd286-168">More formally, we say that such a gate set is universal if for every error tolerance $\epsilon>0$ there exists $G_1,\ldots, G_N$ such that  the distance between $G_N\ldots G_1$ and $U$ is at most $\epsilon$.</span></span> <span data-ttu-id="fd286-169">Idealmente, o valor de $N $ necessário para atingir esta distância de $\epsilon deve escalar $ poli-logaritmicamente com $1/\epsilon $ .</span><span class="sxs-lookup"><span data-stu-id="fd286-169">Ideally the value of $N$ needed to reach this distance of $\epsilon$ should scale poly-logarithmically with $1/\epsilon$.</span></span>

<span data-ttu-id="fd286-170">Como é um conjunto de portão universal na prática?</span><span class="sxs-lookup"><span data-stu-id="fd286-170">What does such a universal gate set look like in practice?</span></span>  <span data-ttu-id="fd286-171">O portão universal mais simples definido para portas de um único qubit consiste em apenas dois portões: o portão Hadamard $H $ e o chamado portão $T $ -gate (também conhecido como portão $\pi/8): $</span><span class="sxs-lookup"><span data-stu-id="fd286-171">The simplest such universal gate set for single-qubit gates consists of only two gates: the Hadamard gate $H$ and the so-called $T$-gate (also known as the $\pi/8$ gate):</span></span>

<span data-ttu-id="fd286-172">$$ H = \frac{1 } {\sqrt{2 } }\start{ bmatrix } 1 & \\ \\ 1 &-1 \end{,\qquad bmatrix } T = \begin{ bmatrix } 1 & \\ \\ 0 0 & e^{i\pi/4 } \end{ bmatrix } .</span><span class="sxs-lookup"><span data-stu-id="fd286-172">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix},\qquad T=\begin{bmatrix} 1 & 0 \\\\  0 & e^{i\pi/4} \end{bmatrix}.</span></span>
$$

<span data-ttu-id="fd286-173">No entanto, por razões práticas relacionadas com a correção de erros quânticos, pode ser mais conveniente considerar um conjunto de portão maior, nomeadamente um que pode ser gerado usando $H $ e $T $ .</span><span class="sxs-lookup"><span data-stu-id="fd286-173">However, for practical reasons related to quantum error correction it can be more convenient to consider a larger gate set, namely one that can be generated using $H$ and $T$.</span></span>
<span data-ttu-id="fd286-174">Podemos classificar os portões quânticos em duas categorias: portas clifford e o $ $T-gate.</span><span class="sxs-lookup"><span data-stu-id="fd286-174">We can classify the quantum gates into two categories: Clifford gates and the $T$-gate.</span></span>
<span data-ttu-id="fd286-175">Esta subdivisão é útil porque em muitos esquemas de correção de erros quânticos os chamados portões Clifford são fáceis de implementar, ou seja, exigem muito poucos recursos em termos de operações e qubits para implementar falhas tolerantes, enquanto os portões não-Clifford são bastante dispendiosos quando exigem tolerância à falha.</span><span class="sxs-lookup"><span data-stu-id="fd286-175">This subdivision is useful because in many quantum error correction schemes the so-called Clifford gates are easy to implement, that is they require very few resources in terms of operations and qubits to implement fault tolerantly, whereas non-Clifford gates are quite costly when requiring fault tolerance.</span></span> <span data-ttu-id="fd286-176">O conjunto padrão de portas clifford single-qubit, [incluído por padrão em Q#](xref:microsoft.quantum.libraries.standard.prelude), incluem</span><span class="sxs-lookup"><span data-stu-id="fd286-176">The standard set of single-qubit Clifford gates, [included by default in Q#](xref:microsoft.quantum.libraries.standard.prelude), include</span></span>

<span data-ttu-id="fd286-177">$$ H = \frac{1 } {\sqrt{2 } }\start{ bmatrix } 1 & 1 \\ \\ &-1 \end{ bmatrix } \qquad S =\begin{ bmatrix } 1 & \\ \\ 0 0 & i \end{ bmatrix } = T^2,\qquad X = \start{ bmatrix } 0 &\\ \\ 1 & 1 \end{ bmatrix } = HT^4H, $$</span><span class="sxs-lookup"><span data-stu-id="fd286-177">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix} ,\qquad S =\begin{bmatrix} 1 & 0 \\\\  0 & i \end{bmatrix}= T^2,\qquad X=\begin{bmatrix} 0 &1 \\\\  1& 0 \end{bmatrix}= HT^4H, $$</span></span>

<span data-ttu-id="fd286-178">$$ Y = \start bmatrix } 0 & -i \\ \\ i & 0 \end{ bmatrix } =T^2HT^4 HT^6, \qquad Z = \begin{ bmatrix }1&\\\\ 0 & -1 \end{ bmatrix } =T^4.</span><span class="sxs-lookup"><span data-stu-id="fd286-178">$$ Y = \begin{bmatrix} 0 & -i \\\\  i & 0 \end{bmatrix}=T^2HT^4  HT^6, \qquad Z=\begin{bmatrix}1&0\\\\ 0&-1 \end{bmatrix}=T^4.</span></span>
$$

<span data-ttu-id="fd286-179">Aqui as operações $X $ , $Y e $Z são $ $ usadas com frequência e são nomeadas [*operadoras Pauli*](https://en.wikipedia.org/wiki/Pauli_matrices) em homenagem ao seu criador Wolfgang Pauli.</span><span class="sxs-lookup"><span data-stu-id="fd286-179">Here the operations $X$, $Y$ and $Z$ are used especially frequently and are named [*Pauli operators*](https://en.wikipedia.org/wiki/Pauli_matrices) after their creator Wolfgang Pauli.</span></span>
<span data-ttu-id="fd286-180">Juntamente com o portão não-Clifford (o $T $ -portão), estas operações podem ser compostas para aproximar qualquer transformação unitária num único qubit.</span><span class="sxs-lookup"><span data-stu-id="fd286-180">Together with the non-Clifford gate (the $T$-gate), these operations can be composed to approximate any unitary transformation on a single qubit.</span></span>

<span data-ttu-id="fd286-181">Para obter mais informações sobre estas operações, as suas representações de esfera bloch e implementações Q#, consulte [Operações e Funções Intrínsecas](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span><span class="sxs-lookup"><span data-stu-id="fd286-181">For more information on these operations, their Bloch sphere representations and Q# implementations, see [Intrinsic Operations and Functions](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span></span>

<span data-ttu-id="fd286-182">Como exemplo de como as transformações unitárias podem ser construídas a partir destes primitivos, as três transformações representadas nas esferas bloch acima correspondem à sequência de portão $\begin{ bmatrix } \\ \\ 10 \end\ bmatrix } \maps to HZH \start{ bmatrix } \\ \\ 1 0 \end{ bmatrix } = \start{ bmatrix } \\ \\ 0 1 \end$ bmatrix }</span><span class="sxs-lookup"><span data-stu-id="fd286-182">As an example of how unitary transformations can be built from these primitives, the three transformations pictured in the Bloch spheres above correspond to the gate sequence $\begin{bmatrix} 1 \\\\  0 \end{bmatrix} \mapsto HZH \begin{bmatrix} 1 \\\\  0 \end{bmatrix} = \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span>

<span data-ttu-id="fd286-183">Embora os anteriores constituam os portões primitivos mais populares para descrever operações no nível lógico da pilha (pense no nível lógico como o nível do algoritmo quântico), é muitas vezes conveniente considerar operações menos básicas a nível algorítmico, por exemplo operações mais próximas de um nível de descrição da função.</span><span class="sxs-lookup"><span data-stu-id="fd286-183">While the previous constitute the most popular primitive gates for describing operations on the logical level of the stack (think of the logical level as the level of the quantum algorithm), it is often convenient to consider less basic operations at the algorithmic level, for example operations closer to a function description level.</span></span> <span data-ttu-id="fd286-184">Felizmente, o Q# também tem métodos disponíveis para implementar unitários de alto nível, que por sua vez permitem a implementação de algoritmos de alto nível sem decompor explicitamente tudo até Clifford e $ $T-gates.</span><span class="sxs-lookup"><span data-stu-id="fd286-184">Fortunately, Q# also has methods available for implementing higher-level unitaries, which in turn allow high-level algorithms to be implemented without explicitly decomposing everything down to Clifford and $T$-gates.</span></span>

<span data-ttu-id="fd286-185">O mais simples tão primitivo é a única rotação qubit.</span><span class="sxs-lookup"><span data-stu-id="fd286-185">The simplest such primitive is the single qubit-rotation.</span></span> <span data-ttu-id="fd286-186">Três rotações de um único qubit são tipicamente consideradas: $R_x, $ $R_y $ e $R_z $ .</span><span class="sxs-lookup"><span data-stu-id="fd286-186">Three single-qubit rotations are typically considered: $R_x$, $R_y$ and $R_z$.</span></span> <span data-ttu-id="fd286-187">Para visualizar a ação da rotação $R_x(\theta)$, por exemplo, imagine apontar o polegar direito ao longo da direção do $x $ -eixo da esfera Bloch e rodar o vetor com a mão através de um ângulo de raios $\theta/2. $</span><span class="sxs-lookup"><span data-stu-id="fd286-187">To visualize the action of the rotation $R_x(\theta)$, for example, imagine pointing your right thumb along the direction of the $x$-axis of the Bloch sphere and rotating the vector with your hand through an angle of $\theta/2$ radians.</span></span> <span data-ttu-id="fd286-188">Este fator confuso de $2 $ decorre do facto de que os vetores ortogonais são de $180^\circ $ separados quando traçados na esfera bloch, mas na verdade são graus de $90^\circ $ separados geometricamente.</span><span class="sxs-lookup"><span data-stu-id="fd286-188">This confusing factor of $2$ arises from the fact that orthogonal vectors are $180^\circ$ apart when plotted on the Bloch sphere, yet are actually $90^\circ$ degrees apart geometrically.</span></span> <span data-ttu-id="fd286-189">As matrizes unitárias correspondentes são:</span><span class="sxs-lookup"><span data-stu-id="fd286-189">The corresponding unitary matrices are:</span></span>

<span data-ttu-id="fd286-190">\start{align}\*&R_z(\theta) = e^{-i\theta Z/2 } = \start{{-i\theta/2 bmatrix } & } \\\\ 0 & e^{i\theta/2 } \end{ bmatrix } , \\ \\ &R_x(\theta) = e^{-i\theta X/2 = } HR_z(\theta)H = \start\ bmatrix } \cos (\theta/2) & -i\sin(\theta/2) \\ \\ -i\sin (\theta/2) & \cos(\theta/2) \end{ bmatrix } , \\ \\ &R_y(\theta) = e^{-i\theta Y/2 } = SHR_z(\theta)HS^\dagger = \start{ bmatrix } \cos (\theta/2) & -\sin(\theta/2) \\ \\ \sin(\theta/2) & \cos (\theta/2) \end{align bmatrix } \*}</span><span class="sxs-lookup"><span data-stu-id="fd286-190">\begin{align *} &R_z(\theta) = e^{-i\theta Z/2} = \begin{bmatrix} e^{-i\theta/2} & 0\\\\  0& e^{i\theta/2} \end{bmatrix}, \\\\ &R_x(\theta) = e^{-i\theta X/2} = HR_z(\theta)H = \begin{bmatrix} \cos(\theta/2) & -i\sin(\theta/2)\\\\  -i\sin(\theta/2) & \cos(\theta/2) \end{bmatrix}, \\\\ &R_y(\theta) = e^{-i\theta Y/2} = SHR_z(\theta)HS^\dagger = \begin{bmatrix} \cos(\theta/2) & -\sin(\theta/2)\\\\  \sin(\theta/2) & \cos(\theta/2) \end{bmatrix}. \end{align*}</span></span>

<span data-ttu-id="fd286-191">Assim como qualquer três rotações podem ser combinadas para realizar uma rotação arbitrária em três dimensões, pode ser visto a partir da representação da esfera bloch que qualquer matriz unitária pode ser escrita como uma sequência de três rotações também.</span><span class="sxs-lookup"><span data-stu-id="fd286-191">Just as any three rotations can be combined together to perform an arbitrary rotation in three dimensions, it can be seen from the Bloch sphere representation that any unitary matrix can be written as a sequence of three rotations as well.</span></span> <span data-ttu-id="fd286-192">Especificamente, para cada matriz unitária $U $ existe $\alpha,\beta,\gama,\delta $ tal que $U = e^{i \alpha } R_x(\beta)R_z(\gama)R_x(\delta)$.</span><span class="sxs-lookup"><span data-stu-id="fd286-192">Specifically, for every unitary matrix $U$ there exists $\alpha,\beta,\gamma,\delta$ such that $U= e^{i\alpha} R_x(\beta)R_z(\gamma)R_x(\delta)$.</span></span> <span data-ttu-id="fd286-193">Assim, $R_z (\theta)$ e $H $ também formam um conjunto universal de portão, embora não seja um conjunto discreto porque $\\theta $ pode ter qualquer valor.</span><span class="sxs-lookup"><span data-stu-id="fd286-193">Thus $R_z(\theta)$ and $H$ also form a universal gate set although it is not a discrete set because $\theta$ can take any value.</span></span> <span data-ttu-id="fd286-194">Por esta razão, e devido a aplicações em simulação quântica, tais portões contínuos são cruciais para a computação quântica, especialmente ao nível do design do algoritmo quântico.</span><span class="sxs-lookup"><span data-stu-id="fd286-194">For this reason, and due to applications in quantum simulation, such continuous gates are crucial for quantum computation, especially at the quantum algorithm design level.</span></span> <span data-ttu-id="fd286-195">Para conseguir a implementação de hardware tolerante a falhas, acabarão por ser compilados em sequências discretas de portão que se aproximam destas rotações.</span><span class="sxs-lookup"><span data-stu-id="fd286-195">To achieve fault-tolerant hardware implementation, they will ultimately be compiled into discrete gate sequences that closely approximate these rotations.</span></span>
