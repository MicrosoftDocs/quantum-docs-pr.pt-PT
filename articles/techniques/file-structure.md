---
title: Descrição geral do programa Q#
description: Aprenda a estrutura básica de um programa quântico e como representa transformações de estados quânticos.
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.techniques.file-structure
ms.openlocfilehash: 5c75bb5499efac2c49cbfc4555fd15b3e072181c
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: pt-PT
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907703"
---
# <a name="q-program-overview"></a><span data-ttu-id="a6eb5-103">Descrição geral do programa Q#</span><span class="sxs-lookup"><span data-stu-id="a6eb5-103">Q# program overview</span></span>

<span data-ttu-id="a6eb5-104">Q# é uma linguagem de programação escalável, multi-paradigma, específica de domínio para computação quântica.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-104">Q# is a scalable, multi-paradigm, domain-specific programming language for quantum computing.</span></span> <span data-ttu-id="a6eb5-105">Q# é uma linguagem de programação quântica na qual pode ser usada para descrever como as instruções são executadas em máquinas quânticas.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-105">Q# is a quantum programming language in that it can be used to describe how instructions are executed on quantum machines.</span></span> <span data-ttu-id="a6eb5-106">As máquinas que podem ser direcionadas vão desde simuladores a hardware quântico real.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-106">The machines that can be targeted range from simulators to actual quantum hardware.</span></span> <span data-ttu-id="a6eb5-107">Q# é escalável: pode ser usado para escrever programas de demonstração simples como teleport que funcionam em alguns qubits, mas também suporta a escrita de grandes e sofisticados programas como simulações de moléculas complexas que exigirão grandes máquinas com milhões de qubits.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-107">Q# is scalable: it can be used to write simple demonstration programs like teleport that run on a few qubits, but also supports writing large, sophisticated programs such as simulations of complex molecules that will require large machines with millions of qubits.</span></span> <span data-ttu-id="a6eb5-108">Mesmo que as grandes máquinas físicas ainda estejam no futuro, Q# permite que um programador programe algoritmos quânticos complexos agora.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-108">Even though large physical machines are still in the future, Q# allows a programmer to program complex quantum algorithms now.</span></span> <span data-ttu-id="a6eb5-109">Além disso, Q# suporta várias tarefas como depuração, perfis, estimativa de recursos e certas simulações de propósito especial de uma forma escalável.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-109">What is more, Q# supports various tasks such as debugging, profiling, resource estimation, and certain special-purpose simulations in a scalable way.</span></span> 

<span data-ttu-id="a6eb5-110">Do ponto de vista técnico, um programa quântico pode ser visto como um conjunto particular de funções clássicas que, quando chamadas, geram circuitos quânticos como seus efeitos colaterais.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-110">From a technical perspective, a quantum program can be seen as a particular set of classical functions which, when called, generate quantum circuits as their side effects.</span></span> <span data-ttu-id="a6eb5-111">Uma consequência importante dessa visão é que um programa escrito em Q# não modela diretamente qubits em si, mas descreve como um computador de controlo clássico interage com esses qubits.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-111">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="a6eb5-112">Por design, Q# assim não define estados quânticos ou outras propriedades da mecânica quântica diretamente, mas sim faz-o indiretamente através da ação das várias subrotinas definidas na linguagem.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-112">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly, but rather does so indirectly through the action of the various subroutines defined in the language.</span></span>
<span data-ttu-id="a6eb5-113">Por exemplo, considere o estado $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discutido no guia [Quantum Computing Concepts.](xref:microsoft.quantum.concepts.intro)</span><span class="sxs-lookup"><span data-stu-id="a6eb5-113">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="a6eb5-114">Para preparar este estado em Q#, usamos os factos de que os qubits são inicializados no estado de $\ket{0}$, e que $\ket{+} = H\ket{0}$, onde $H$ é a transformação de Hadamard:</span><span class="sxs-lookup"><span data-stu-id="a6eb5-114">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0〉.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0〉 = |+〉, as we wanted.
}
```
## <a name="q-tranformations-of-quantum-states"></a><span data-ttu-id="a6eb5-115">Q# tranformações de estados quânticos</span><span class="sxs-lookup"><span data-stu-id="a6eb5-115">Q# tranformations of quantum states</span></span>

<span data-ttu-id="a6eb5-116">Importante, ao escrever o programa acima, não nos referimos explicitamente ao estado dentro de Q#, mas sim descrevemos como o estado foi *transformado* pelo nosso programa.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-116">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="a6eb5-117">Assim, semelhante à forma como um programa de som gráfico acumula uma descrição das transformações a cada vértice, um programa quântico em Q# acumula transformações em estados quânticos.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-117">Thus, similar to how a graphics shader program accumulates a description of transformations to each vertex, a quantum program in Q# accumulates transformations to quantum states.</span></span>
<span data-ttu-id="a6eb5-118">Isto permite-nos ser inteiramente agnósticos sobre o que um estado quântico *é* mesmo em cada máquina-alvo, que pode ter interpretações diferentes dependendo da máquina.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-118">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="a6eb5-119">Do ponto de vista de um programa Q#, um qubit é uma referência inteiramente opaca à estrutura interna de uma máquina-alvo.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-119">From the perspective of a Q# program, a qubit is an entirely opaque reference to the internal structure of a target machine.</span></span>
<span data-ttu-id="a6eb5-120">Um programa Q# não tem capacidade de introspeção no estado de um qubit, a sua representação numa máquina-alvo, ou mesmo se é o mesmo qubit que qualquer outro qubit disponível para o programa.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-120">A Q# program has no ability to introspect into the state of a qubit, its representation on a target machine, or even whether it is the same qubit as any other qubit available to the program.</span></span>
<span data-ttu-id="a6eb5-121">Pelo contrário, um programa pode chamar operações como `Measure` para aprender informações a partir de um qubit, e chamar operações como `X` e `H` para agir sobre o estado de um qubit.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-121">Rather, a program can call operations such as `Measure` to learn information from a qubit, and call operations such as `X` and `H` to act on the state of a qubit.</span></span>
<span data-ttu-id="a6eb5-122">Estas operações não têm definição intrínseca dentro da linguagem, e são feitas de concreto apenas pela máquina-alvo usada para executar um programa Q# particular.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-122">These operations have no intrinsic definition within the language, and are made concrete only by the target machine used to run a particular Q# program.</span></span>
<span data-ttu-id="a6eb5-123">Um programa Q# recombina estas operações como definida por uma máquina-alvo para criar novas operações de alto nível para expressar a computação quântica.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-123">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="a6eb5-124">Desta forma, Q# torna fácil expressar a lógica subjacente aos algoritmos quânticos e híbridos quânticos-clássicos, ao mesmo tempo que é geral no que diz respeito à estrutura de uma máquina-alvo ou simulador.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-124">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum-classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="a6eb5-125">Q# operações e funções</span><span class="sxs-lookup"><span data-stu-id="a6eb5-125">Q# operations and functions</span></span>

<span data-ttu-id="a6eb5-126">Concretamente, um programa Q# é composto por uma ou mais *operações,* uma ou mais *funções,* e tipos definidos pelo utilizador.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-126">Concretely, a Q# program is comprised of one or more *operations*, one or more *functions*, and user defined types.</span></span> <span data-ttu-id="a6eb5-127">As operações são usadas para descrever as transformações do estado de uma máquina quântica e são o bloco de construção mais básico dos programas Q#.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-127">Operations are used to describe the transformations of the state of a quantum machine and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="a6eb5-128">Cada operação definida em Q# pode então ligar para qualquer número de outras operações, incluindo as operações *intrínsecas* incorporadas implementadas por uma máquina-alvo.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-128">Each operation defined in Q# may then call any number of other operations, including the built-in *intrinsic* operations implemented by a target machine.</span></span>
<span data-ttu-id="a6eb5-129">Quando compilado, cada operação é representada como um tipo de classe .NET que pode ser fornecido às máquinas-alvo.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-129">When compiled, each operation is represented as a .NET class type that can be provided to target machines.</span></span>

<span data-ttu-id="a6eb5-130">Em contraste com as operações, as funções são usadas para descrever comportamentos puramente clássicos e não têm quaisquer efeitos além de calcular valores de saída clássicos.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-130">In contrast to operations, functions are used to describe purely classical behavior and do not have any effects besides computing classical output values.</span></span> <span data-ttu-id="a6eb5-131">Q# é uma linguagem fortemente dactilografada e vem com um conjunto de tipos primitivos incorporados, bem como suporte para tipos definidos pelo utilizador.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-131">Q# is a strongly typed language and comes with a set of built-in primitive types as well as support for user defined types.</span></span> 

<span data-ttu-id="a6eb5-132">Ao longo do resto deste guia, veremos como usar diferentes conceitos e construções linguísticas para nos ajudar a definir programas quânticos complexos através dos blocos básicos de construção de operações, funções e tipos.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-132">Throughout the rest of this guide, we will see how to use different language concepts and constructs to help us define complex quantum programs through the basic building blocks of operations, functions, and types.</span></span> 

## <a name="structure-of-q-source-files"></a><span data-ttu-id="a6eb5-133">Estrutura de Ficheiros De Origem Q#</span><span class="sxs-lookup"><span data-stu-id="a6eb5-133">Structure of Q# Source Files</span></span>

<span data-ttu-id="a6eb5-134">Minimamente, um ficheiro de origem Q# consiste numa declaração de *espaço de nome,* que especifica um espaço de nome .NET que conterá as definições no ficheiro fonte.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-134">Minimally, a Q# source file consists of a *namespace declaration*, which specifies a .NET namespace which will contain the definitions in the source file.</span></span>
<span data-ttu-id="a6eb5-135">As definições de outros ficheiros e bibliotecas de origem Q# podem ser incluídas utilizando a declaração `open`.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-135">Definitions from other Q# source files and libraries can be included using the `open` statement.</span></span>
<span data-ttu-id="a6eb5-136">Por exemplo, a maioria das operações que definem portões fundamentais são definidas no espaço de nome <xref:microsoft.quantum.intrinsic>.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-136">For instance, most of the operations defining fundamental gates are defined in the <xref:microsoft.quantum.intrinsic> namespace.</span></span>
<span data-ttu-id="a6eb5-137">Para disponibilizar isto ao nosso código, simplesmente `open` esse espaço de nome no topo de cada ficheiro:</span><span class="sxs-lookup"><span data-stu-id="a6eb5-137">To make this available to our code, we simply `open` that namespace at the top of each file:</span></span>

```qsharp
namespace Example {
    open Microsoft.Quantum.Intrinsic;

    // ...
}
```

<span data-ttu-id="a6eb5-138">Dentro de um espaço de nome, cada ficheiro de origem Q# pode definir qualquer combinação de *operações,* *funções*e *tipos definidos pelo utilizador*.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-138">Within a namespace, each Q# source file can define any combination of *operations*, *functions*, and *user-defined types*.</span></span>
<span data-ttu-id="a6eb5-139">No resto desta secção, descreveremos cada um por sua vez e forneceremos exemplos de como podem ser usados na prática para fazer programas quânticos úteis.</span><span class="sxs-lookup"><span data-stu-id="a6eb5-139">In the rest of this section, we will describe each in turn and provide examples of how they can be used in practice to make useful quantum programs.</span></span>
