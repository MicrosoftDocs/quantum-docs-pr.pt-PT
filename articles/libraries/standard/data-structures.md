---
title: Estruturas de dados nas bibliotecas padrão Q#
description: Conheça estruturas de dados, oráculos e geradores dinâmicos nas bibliotecas padrão Microsoft Q#.
author: QuantumWriter
uid: microsoft.quantum.libraries.data-structures
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 46ac6794d1e21e111aa1d98e11a6f83194f8d54e
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: pt-PT
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907788"
---
# <a name="data-structures-and-modeling"></a><span data-ttu-id="4e6e8-103">Estruturas de Dados e Modelação</span><span class="sxs-lookup"><span data-stu-id="4e6e8-103">Data Structures and Modeling</span></span> #

## <a name="classical-data-structures"></a><span data-ttu-id="4e6e8-104">Estruturas de dados clássicas</span><span class="sxs-lookup"><span data-stu-id="4e6e8-104">Classical Data Structures</span></span> ##

<span data-ttu-id="4e6e8-105">Juntamente com os tipos definidos pelo utilizador para representar conceitos quânticos, o cânion também fornece operações, funções e tipos para trabalhar com dados clássicos utilizados no controlo de sistemas quânticos.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-105">Along with user-defined types for representing quantum concepts, the canon also provides operations, functions, and types for working with classical data used in the control of quantum systems.</span></span>
<span data-ttu-id="4e6e8-106">Por exemplo, a função <xref:microsoft.quantum.arrays.reversed> toma uma matriz como entrada e devolve a mesma matriz em ordem inversa.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-106">For instance, the <xref:microsoft.quantum.arrays.reversed> function takes an array as input and returns the same array in reverse order.</span></span>
<span data-ttu-id="4e6e8-107">Isto pode então ser usado numa série de tipos `Qubit[]` para evitar ter de aplicar portões desnecessários de $\operatorname{SWAP}$ quando converter entre representações quânticas de inteiros.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-107">This can then be used on an array of type `Qubit[]` to avoid having to apply unnecessary $\operatorname{SWAP}$ gates when converting between quantum representations of integers.</span></span>
<span data-ttu-id="4e6e8-108">Da mesma forma, vimos na secção anterior que os tipos do formulário `(Int, Int -> T)` podem ser úteis para representar coleções de acesso aleatório, pelo que a função <xref:microsoft.quantum.arrays.lookupfunction> fornece uma forma conveniente de construir tais tipos a partir de tipos de matrizes.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-108">Similarly, we saw in the previous section that types of the form `(Int, Int -> T)` can be useful for representing random access collections, so the <xref:microsoft.quantum.arrays.lookupfunction> function provides a convenient way of constructing such types from array types.</span></span>

### <a name="pairs"></a><span data-ttu-id="4e6e8-109">Pares</span><span class="sxs-lookup"><span data-stu-id="4e6e8-109">Pairs</span></span> ###

<span data-ttu-id="4e6e8-110">O cânon suporta notação de estilo funcional para pares, complementando o acesso a tuples por desconstrução:</span><span class="sxs-lookup"><span data-stu-id="4e6e8-110">The canon supports functional-style notation for pairs, complementing accessing tuples by deconstruction:</span></span>

```qsharp
let pair = (PauliZ, register); // type (Pauli, Qubit[])
ApplyToEach(H, Snd(pair)); // No need to deconstruct to access the register.
```

### <a name="arrays"></a><span data-ttu-id="4e6e8-111">Matrizes</span><span class="sxs-lookup"><span data-stu-id="4e6e8-111">Arrays</span></span> ###

<span data-ttu-id="4e6e8-112">O cânon fornece várias funções para manipular matrizes.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-112">The canon provides several functions for manipulating arrays.</span></span>
<span data-ttu-id="4e6e8-113">Estas funções são tipo-parametrizados, e assim podem ser usadas com matrizes de qualquer tipo Q#.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-113">These functions are type-parameterized, and thus can be used with arrays of any Q# type.</span></span>
<span data-ttu-id="4e6e8-114">Por exemplo, a função <xref:microsoft.quantum.arrays.reversed> devolve uma nova matriz cujos elementos estão em ordem inversa a partir da sua entrada.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-114">For instance, the <xref:microsoft.quantum.arrays.reversed> function returns a new array whose elements are in reverse order from its input.</span></span>
<span data-ttu-id="4e6e8-115">Isto pode ser usado para alterar a forma como um registo quântico é representado ao chamar operações:</span><span class="sxs-lookup"><span data-stu-id="4e6e8-115">This can be used to change how a quantum register is represented when calling operations:</span></span>

```qsharp
let leRegister = LittleEndian(register);
// QFT expects a BigEndian, so we can reverse before calling.
QFT(BigEndian(Reversed(leRegister!)));
// This is how the LittleEndianAsBigEndian function is implemented:
QFT(LittleEndianAsBigEndian(leRegister));
```

<span data-ttu-id="4e6e8-116">Da mesma forma, a função <xref:microsoft.quantum.arrays.subarray> pode ser utilizada para reordenar ou tomar subconjuntos dos elementos de uma matriz:</span><span class="sxs-lookup"><span data-stu-id="4e6e8-116">Similarly, the <xref:microsoft.quantum.arrays.subarray> function can be used to reorder or take subsets of the elements of an array:</span></span>

```qsharp
// Applies H to qubits 2 and 5.
ApplyToEach(H, Subarray([2, 5], register));
```

<span data-ttu-id="4e6e8-117">Quando combinado com o controlo de fluxo, funções de manipulação de matriz, como <xref:microsoft.quantum.arrays.zip>, podem fornecer uma forma poderosa de expressar programas quânticos:</span><span class="sxs-lookup"><span data-stu-id="4e6e8-117">When combined with flow control, array manipulation functions such as <xref:microsoft.quantum.arrays.zip> can provide a powerful way to express quantum programs:</span></span>

```qsharp
// Applies X₃ Y₁ Z₇ to a register of any size.
ApplyToEach(
    ApplyPauli(_, register),
    Map(
        EmbedPauli(_, _, Length(register)),
        Zip([PauliX, PauliY, PauliZ], [3, 1, 7])
    )
);
```

## <a name="oracles"></a><span data-ttu-id="4e6e8-118">Oráculos</span><span class="sxs-lookup"><span data-stu-id="4e6e8-118">Oracles</span></span> ##

<span data-ttu-id="4e6e8-119">Na [estimativa](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) de fase e na literatura de amplificação de [amplitude,](https://en.wikipedia.org/wiki/Amplitude_amplification) o conceito de um oráculo aparece frequentemente.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-119">In the [phase estimation](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) and [amplitude amplification](https://en.wikipedia.org/wiki/Amplitude_amplification) literature the concept of an oracle appears frequently.</span></span>
<span data-ttu-id="4e6e8-120">Aqui o termo oráculo refere-se a uma subrotina quântica blackbox que age sobre um conjunto de qubits e devolve a resposta como uma fase.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-120">Here the term oracle refers to a blackbox quantum subroutine that acts upon a set of qubits and returns the answer as a phase.</span></span>
<span data-ttu-id="4e6e8-121">Esta subrotina pode muitas vezes ser considerada como uma entrada para um algoritmo quântico que aceita o oráculo, além de outros parâmetros, e aplica uma série de operações quânticas e trata uma chamada para esta subrotina quântica como se fosse um portão fundamental.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-121">This subroutine often can be thought of as an input to a quantum algorithm that accepts the oracle, in addition to some other parameters, and applies a series of quantum operations and treating a call to this quantum subroutine as if it were a fundamental gate.</span></span>
<span data-ttu-id="4e6e8-122">Obviamente, para implementar o algoritmo maior, uma decomposição concreta do oráculo em portões fundamentais deve ser fornecida, mas tal decomposição não é necessária para entender o algoritmo que chama o oráculo.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-122">Obviously, in order to actually implement the larger algorithm a concrete decomposition of the oracle into fundamental gates must be provided but such a decomposition is not needed in order to understand the algorithm that calls the oracle.</span></span>
<span data-ttu-id="4e6e8-123">Em Q#, esta abstração é representada usando que as operações são valores de primeira classe, de modo que as operações podem ser passadas para implementações de algoritmos quânticos de forma em caixa preta.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-123">In Q#, this abstraction is represented by using that operations are first-class values, such that operations can be passed to implementations of quantum algorithms in a black-box manner.</span></span>
<span data-ttu-id="4e6e8-124">Além disso, os tipos definidos pelo utilizador são utilizados para rotular as diferentes representações do oráculo de uma forma segura, dificultando acidentalmente a conflação de diferentes tipos de operações de caixa preta.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-124">Moreover, user-defined types are used to label the different oracle representations in a type-safe way, making it difficult to accidentally conflate different kinds of black box operations.</span></span>

<span data-ttu-id="4e6e8-125">Tais oráculos aparecem em vários contextos diferentes, incluindo exemplos famosos como [a pesquisa de Grover](https://en.wikipedia.org/wiki/Grover%27s_algorithm) e algoritmos de simulação quântica.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-125">Such oracles appear in a number of different contexts, including famous examples such as [Grover's search](https://en.wikipedia.org/wiki/Grover%27s_algorithm) and quantum simulation algorithms.</span></span>
<span data-ttu-id="4e6e8-126">Aqui focamo-nos nos oráculos necessários para apenas duas aplicações: amplificação de amplitude e estimativa de fase.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-126">Here we focus on the oracles needed for just two applications: amplitude amplification and phase estimation.</span></span>
<span data-ttu-id="4e6e8-127">Primeiro discutiremos os oráculos de amplificação de amplitude antes de avançar para a estimativa de fase.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-127">We will first discuss amplitude amplification oracles before proceeding to phase estimation.</span></span>

### <a name="amplitude-amplification-oracles"></a><span data-ttu-id="4e6e8-128">Oráculos de amplificação amplitude</span><span class="sxs-lookup"><span data-stu-id="4e6e8-128">Amplitude Amplification Oracles</span></span> ###

<span data-ttu-id="4e6e8-129">O algoritmo de amplificação de amplitude visa realizar uma rotação entre um estado inicial e um estado final aplicando uma sequência de reflexões do estado.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-129">The amplitude amplification algorithm aims to perform a rotation between an initial state and a final state by applying a sequence of reflections of the state.</span></span>
<span data-ttu-id="4e6e8-130">Para que o algoritmo funcione, precisa de uma especificação de ambos os estados.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-130">In order for the algorithm to function, it needs a specification of both of these states.</span></span>
<span data-ttu-id="4e6e8-131">Estas especificações são dadas por dois oráculos.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-131">These specifications are given by two oracles.</span></span>
<span data-ttu-id="4e6e8-132">Estes oráculos funcionam dividindo as inputs em dois espaços, um subespaço "alvo" e um subespaço "inicial".</span><span class="sxs-lookup"><span data-stu-id="4e6e8-132">These oracles work by breaking the inputs into two spaces, a "target" subspace and an "initial" subspace.</span></span>
<span data-ttu-id="4e6e8-133">Os oráculos identificam esses subespaços, semelhantes à forma como os operadores pauli identificam dois espaços, aplicando uma fase de $\pm de $\pm 1$1$ para estes espaços.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-133">The oracles identify such subspaces, similar to how Pauli operators identify two spaces, by applying a $\pm 1$ phase to these spaces.</span></span>
<span data-ttu-id="4e6e8-134">A principal diferença é que estes espaços não precisam de ser espaços a meio nesta aplicação.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-134">The main difference is that these spaces need not be half-spaces in this application.</span></span>
<span data-ttu-id="4e6e8-135">Note também que estes dois subespaços não são geralmente mutuamente exclusivos: haverá vetores que são membros de ambos os espaços.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-135">Also note that these two subspaces are not usually mutually exclusive: there will be vectors that are members of both spaces.</span></span>
<span data-ttu-id="4e6e8-136">Se isso não fosse verdade, então a amplificação da amplitude não teria qualquer efeito, por isso precisamos do subespaço inicial para ter sobreposição não-zero com o subespaço alvo.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-136">If this were not true then amplitude amplification would have no effect so we need the initial subspace to have non-zero overlap with the target subspace.</span></span>

<span data-ttu-id="4e6e8-137">Vamos denotar o primeiro oráculo de que precisamos para que a amplificação de amplitude seja $P\_0$, definida para ter a seguinte ação.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-137">We will denote the first oracle that we need for amplitude amplification to be $P\_0$, defined to have the following action.</span></span>  <span data-ttu-id="4e6e8-138">Para todos os estados $\ket{x}$ no subespaço "inicial" $P\_0 \ket{x} = -\ket{x}$ e para todos os estados $\ket{y}$ que não estão neste subespaço temos $P\_0 \ket{y} = \ket{y}$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-138">For all states $\ket{x}$ in the "initial" subspace $P\_0 \ket{x} = -\ket{x}$ and for all states $\ket{y}$ that are not in this subspace we have $P\_0 \ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="4e6e8-139">O oráculo que marca o subespaço alvo, $P_1$, toma exatamente a mesma forma.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-139">The oracle that marks the target subspace, $P_1$, takes exactly the same form.</span></span>
<span data-ttu-id="4e6e8-140">Para todos os estados $\ket{x}$ no subespaço alvo (isto é, para todos os estados que você gostaria que o algoritmo fosse de saída), $P_1\ket{x} = -\ket{x}$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-140">For all states $\ket{x}$ in the target subspace (i.e., for all states that you'd like the algorithm to output), $P_1\ket{x} = -\ket{x}$.</span></span>
<span data-ttu-id="4e6e8-141">Da mesma forma, para todos os estados $\ket{y}$ que não estão no subespaço alvo $P_1\ket{y} = \ket{y}$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-141">Similarly, for all states $\ket{y}$ that are not in the target subspace $P_1\ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="4e6e8-142">Estas duas reflexões são então combinadas para formar um operador que promulga um único passo de amplificação de amplitude, $Q = -P_0 P_1$, onde o sinal de menos global é apenas importante a considerar em aplicações controladas.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-142">These two reflections are then combined to form an operator that enacts a single step of amplitude amplification, $Q = -P_0 P_1$, where the overall minus sign is only important to consider in controlled applications.</span></span>
<span data-ttu-id="4e6e8-143">A amplificação amplitude prossegue tomando um estado inicial, $\ket{\psi}$ que está no subespaço inicial e, em seguida, executa $\ket{\psi} \mapsto Q^m \ket{\psi}$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-143">Amplitude amplification then proceeds by taking an initial state, $\ket{\psi}$ that is in the initial subspace and then performs $\ket{\psi} \mapsto Q^m \ket{\psi}$.</span></span>
<span data-ttu-id="4e6e8-144">Realizar tal iteração garante que se se começa com um estado inicial que se sobrepõe $\sin^2(\theta)$ com o espaço marcado e depois de $m iterações de$, esta sobreposição torna-se $\sin^2([2m + 1] \theta)$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-144">Performing such an iteration guarantees that if one starts with an initial state that has overlap $\sin^2(\theta)$ with the marked space then after $m$ iterations this overlap becomes $\sin^2([2m + 1] \theta)$.</span></span>
<span data-ttu-id="4e6e8-145">Por isso, normalmente, queremos escolher $m$ para ser um parâmetro gratuito tal que $[2m+1]\theta = \pi/2$; no entanto, tais escolhas rígidas não são tão importantes para algumas formas de amplificação amplitude, como a amplificação de amplitude de ponto fixo.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-145">We therefore typically wish to choose $m$ to be a free parameter such that $[2m+1]\theta = \pi/2$; however, such rigid choices are not as important for some forms of amplitude amplification such as fixed point amplitude amplification.</span></span>
<span data-ttu-id="4e6e8-146">Este processo permite-nos preparar um estado no subespaço marcado usando quadraticamente menos consultas à função de marcação e à função de preparação do Estado do que seria possível num dispositivo estritamente clássico.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-146">This process allows us to prepare a state in the marked subspace using quadratically fewer queries to the marking function and the state preparation function than would be possible on a strictly classical device.</span></span>
<span data-ttu-id="4e6e8-147">É por isso que a amplificação da amplitude é um bloco de construção significativo para muitas aplicações da computação quântica.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-147">This is why amplitude amplification is a significant building block for many applications of quantum computing.</span></span>

<span data-ttu-id="4e6e8-148">Para entender como usar o algoritmo, é útil fornecer um exemplo que dá uma construção dos oráculos.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-148">In order to understand how to use the algorithm, it is useful to provide an example that gives a construction of the oracles.</span></span>  <span data-ttu-id="4e6e8-149">Considere executar o algoritmo do Grover para pesquisas de bases de dados neste cenário.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-149">Consider performing Grover's algorithm for database searches in this setting.</span></span>
<span data-ttu-id="4e6e8-150">Na pesquisa de Grover, o objetivo é transformar o estado $\ket{+}^{\otimes n} = H^{\otimes n} \ket{0}$ em um dos (potencialmente) muitos estados marcados.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-150">In Grover's search the goal is to transform the state $\ket{+}^{\otimes n} = H^{\otimes n} \ket{0}$ into one of (potentially) many marked states.</span></span>
<span data-ttu-id="4e6e8-151">Para simplificar ainda mais, vamos ver o caso em que o único estado marcado é $\ket{0}$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-151">To further simplify, let's just look at the case where the only marked state is $\ket{0}$.</span></span>
<span data-ttu-id="4e6e8-152">Depois temos dois oráculos: um que só marca o estado inicial $\ket{+}{\otimes n}$ com um sinal de menos e outro que marca o estado marcado $\ket{0}$ com um sinal negativo.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-152">Then we have design two oracles: one that only marks the initial state $\ket{+}^{\otimes n}$ with a minus sign and another that marks the marked state $\ket{0}$ with a minus sign.</span></span>
<span data-ttu-id="4e6e8-153">Este último portão pode ser implementado utilizando a seguinte operação de processo, utilizando as operações de fluxo de controlo no cânone:</span><span class="sxs-lookup"><span data-stu-id="4e6e8-153">The latter gate can be implemented using the following process operation, by using the control flow operations in the canon:</span></span>

```qsharp
operation ReflectAboutAllZeros(register : Qubit[]) : Unit 
is Adj + Ctl {

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);

    // Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.
    // This gate will lead to a sign flip if and only if every qubit is
    // $1$, which happens only if each of the qubits were $0$ before step 1.
    Controlled Z(Most(register), Tail(register));

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);
}
```

<span data-ttu-id="4e6e8-154">Este oráculo é então um caso especial da operação <xref:microsoft.quantum.canon.rall1>, que permite rodar por uma fase arbitrária em vez do caso de reflexão $\phi = \pi$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-154">This oracle is then a special case of the <xref:microsoft.quantum.canon.rall1> operation, which allows for rotating by an arbitrary phase instead of the reflection case $\phi = \pi$.</span></span>
<span data-ttu-id="4e6e8-155">Neste caso, `RAll1` é semelhante à operação <xref:microsoft.quantum.intrinsic.r1> prelúdio, na medida em que gira cerca de $\ket{11\cdots1}$ em vez do estado de um qubit único $\ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-155">In this case, `RAll1` is similar to the <xref:microsoft.quantum.intrinsic.r1> prelude operation, in that it rotates about $\ket{11\cdots1}$ instead of the single-qubit state $\ket{1}$.</span></span>

<span data-ttu-id="4e6e8-156">O oráculo que marca o subespaço inicial pode ser construído da mesma forma.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-156">The oracle that marks the initial subspace can be constructed similarly.</span></span>
<span data-ttu-id="4e6e8-157">Em pseudocódigo:</span><span class="sxs-lookup"><span data-stu-id="4e6e8-157">In pseudocode:</span></span>

1. <span data-ttu-id="4e6e8-158">Aplique $H$ portões a cada qubit.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-158">Apply $H$ gates to every qubit.</span></span>
2. <span data-ttu-id="4e6e8-159">Aplique $X$ portões a cada qubit.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-159">Apply $X$ gates to every qubit.</span></span>
3. <span data-ttu-id="4e6e8-160">Aplique um $n-1$ controlado $Z$-gate para o $n^{\text{th}}}$ qubit.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-160">Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.</span></span>
4. <span data-ttu-id="4e6e8-161">Aplique $X$ portões a cada qubit.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-161">Apply $X$ gates to every qubit.</span></span>
5. <span data-ttu-id="4e6e8-162">Aplique $H$ portões a cada qubit.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-162">Apply $H$ gates to every qubit.</span></span>

<span data-ttu-id="4e6e8-163">Desta vez, demonstramos também a utilização de <xref:microsoft.quantum.canon.applywith> juntamente com a operação <xref:microsoft.quantum.canon.rall1> discutida acima:</span><span class="sxs-lookup"><span data-stu-id="4e6e8-163">This time, we also demonstrate using <xref:microsoft.quantum.canon.applywith> together with the <xref:microsoft.quantum.canon.rall1> operation discussed above:</span></span>

```qsharp
operation ReflectAboutInitial(register : Qubit[]) : Unit
is Adj + Ctl {
    ApplyWithCA(ApplyToEach(H, _), ApplyWith(ApplyToEach(X, _), RAll1(_, PI()), _), register);
}
```

<span data-ttu-id="4e6e8-164">Podemos então combinar estes dois oráculos para rodar entre os dois estados e transformar deterministicamente $\ket{+}^{\otimes n}$ a $\ket{0}$ usando uma série de camadas de portões Hadamard que é proporcional a $\sqrt{2^n}$ (ou seja, $m\propto \sqrt{2^n}$) contra as camadas de aproximadamente $2^n$ que seriam necessárias para preparar não deterministicamente o estado de $\ket{0}$, preparando e medindo o estado inicial até que o resultado $0$ seja observado.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-164">We can then combine these two oracles together to rotate between the two states and deterministically transform $\ket{+}^{\otimes n}$ to $\ket{0}$ using a number of layers of Hadamard gates that is proportional to $\sqrt{2^n}$ (ie $m\propto \sqrt{2^n}$) versus the roughly $2^n$ layers that would be needed to non-deterministically prepare the $\ket{0}$ state by preparing and measuring the initial state until the outcome $0$ is observed.</span></span>

### <a name="phase-estimation-oracles"></a><span data-ttu-id="4e6e8-165">Oráculos de estimativa de fase</span><span class="sxs-lookup"><span data-stu-id="4e6e8-165">Phase Estimation Oracles</span></span> ###

<span data-ttu-id="4e6e8-166">Para a estimativa de fase, os oráculos são um pouco mais naturais.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-166">For phase estimation the oracles are somewhat more natural.</span></span>
<span data-ttu-id="4e6e8-167">O objetivo na estimativa de fase é conceber uma subrotina capaz de provar a partir dos valores eigen de uma matriz unitária.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-167">The aim in phase estimation is to design a subroutine that is capable of sampling from the eigenvalues of a unitary matrix.</span></span>
<span data-ttu-id="4e6e8-168">Este método é indispensável na simulação quântica porque para muitos problemas físicos na química e ciência material estes valores eigendão dão as energias do estado terrestre dos sistemas quânticos que nos fornecem informações valiosas sobre os diagramas de fase de materiais e dinâmicas de reação para moléculas.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-168">This method is indispensable in quantum simulation because for many physical problems in chemistry and material science these eigenvalues give the ground-state energies of quantum systems which provides us valuable information about the phase diagrams of materials and reaction dynamics for molecules.</span></span>
<span data-ttu-id="4e6e8-169">Cada sabor da estimativa de fase precisa de uma entrada unitária.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-169">Every flavor of phase estimation needs an input unitary.</span></span>
<span data-ttu-id="4e6e8-170">Este unitário é habitualmente descrito por um de dois tipos de oráculos.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-170">This unitary is customarily described by one of two types of oracles.</span></span>

> [!TIP]
> <span data-ttu-id="4e6e8-171">Ambos os tipos de oráculo descritos abaixo estão cobertos nas amostras.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-171">Both of the oracle types described below are covered in the samples.</span></span>
> <span data-ttu-id="4e6e8-172">Para saber mais sobre oráculos de consulta contínua, consulte a amostra [ **de Estimativa de Fase** ](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="4e6e8-172">To learn more about continuous query oracles, please see the [**PhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation).</span></span>
> <span data-ttu-id="4e6e8-173">Para saber mais sobre os oráculos de consulta discreta, consulte a amostra [ **isingPhaseEstimation** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="4e6e8-173">To learn more about discrete query oracles, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span></span>

<span data-ttu-id="4e6e8-174">O primeiro tipo de oráculo, a que chamamos um oráculo de consulta discreta e representamos com o tipo definido pelo utilizador <xref:microsoft.quantum.oracles.discreteoracle>, envolve simplesmente uma matriz unitária.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-174">The first type of oracle, which we call a discrete query oracle and represent with the user-defined type <xref:microsoft.quantum.oracles.discreteoracle>, simply involves a unitary matrix.</span></span>
<span data-ttu-id="4e6e8-175">Se $U$ é o unitário cujos valores eigen que queremos estimar então o oráculo para $U$ é simplesmente um substituto para uma subrotina que implementa $U$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-175">If $U$ is the unitary whose eigenvalues we wish to estimate then the oracle for $U$ is simply a stand-in for a subroutine that implements $U$.</span></span>
<span data-ttu-id="4e6e8-176">Por exemplo, pode-se levar $U$ para ser o oráculo $Q$ definido acima para estimativa de amplitude.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-176">For example, one could take $U$ to be the oracle $Q$ defined above for amplitude estimation.</span></span>
<span data-ttu-id="4e6e8-177">Os valores eigen desta matriz podem ser usados para estimar a sobreposição entre os estados iniciais e os estados-alvo, $\sin^2(\theta)$, utilizando quadraticamente menos amostras do que se precisaria de outra forma.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-177">The eigenvalues of this matrix can be used to estimate the overlap between the initial and target states, $\sin^2(\theta)$, using quadratically fewer samples than one would need otherwise.</span></span>
<span data-ttu-id="4e6e8-178">Isto ganha a aplicação da estimativa de fase usando o oráculo Grover $Q$ como entrada o apelido de estimativa de amplitude.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-178">This earns the application of phase estimation using the Grover oracle $Q$ as input the moniker of amplitude estimation.</span></span>
<span data-ttu-id="4e6e8-179">Outra aplicação comum, amplamente utilizada na metrologia quântica, envolve estimar um pequeno ângulo de rotação.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-179">Another common application, widely used in quantum metrology, involves estimating a small rotation angle.</span></span>
<span data-ttu-id="4e6e8-180">Por outras palavras, queremos estimar $\theta$ para um portão de rotação desconhecido do formulário $R_z(\theta)$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-180">In other words, we wish to estimate $\theta$ for an unknown rotation gate of the form $R_z(\theta)$.</span></span>
<span data-ttu-id="4e6e8-181">Nesses casos, a subrotina com a qual interagimos para aprender este valor fixo de $\theta$ para o portão é $$ \begin{align} U & = R_z(\theta) \\\\ & = \start{bmatrix} e^{-i \theta / 2} & 0 \\\\ 0 & e{{i\theta/2} \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-181">In such cases, the subroutine that we would interact with in order to learn this fixed value of $\theta$ for the gate is $$ \begin{align} U & = R_z(\theta) \\\\ & = \begin{bmatrix} e^{-i \theta / 2} & 0 \\\\ 0 & e^{i\theta/2} \end{bmatrix}.</span></span>
<span data-ttu-id="4e6e8-182">\end{align} $$</span><span class="sxs-lookup"><span data-stu-id="4e6e8-182">\end{align} $$</span></span>

<span data-ttu-id="4e6e8-183">O segundo tipo de oráculo utilizado na estimativa de fase é o oráculo de consulta contínua, representado pelo tipo <xref:microsoft.quantum.oracles.continuousoracle>.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-183">The second type of oracle used in phase estimation is the continuous query oracle, represented by the <xref:microsoft.quantum.oracles.continuousoracle> type.</span></span>
<span data-ttu-id="4e6e8-184">Um oráculo de consulta contínua para estimativa de fase assume a forma $U(t)$ onde $t$ é um número real clássico conhecido.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-184">A continuous query oracle for phase estimation takes the form $U(t)$ where $t$ is a classically known real number.</span></span>
<span data-ttu-id="4e6e8-185">Se deixarmos $U$ ser um unitário fixo, então o oráculo de consulta contínua assume a forma $U(t) = U^t$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-185">If we let $U$ be a fixed unitary then the continuous query oracle takes the form $U(t) = U^t$.</span></span>
<span data-ttu-id="4e6e8-186">Isto permite-nos consultar matrizes como $\sqrt{U}$, que não poderia ser implementado diretamente no modelo de consulta discreta.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-186">This allows us to query matrices such as $\sqrt{U}$, which could not be implemented directly in the discrete query model.</span></span>

<span data-ttu-id="4e6e8-187">Este tipo de oráculo é valioso quando não está a sondar um determinado unitário, mas prefere aprender as propriedades do gerador do unitário.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-187">This type of oracle is valuable when you're not probing a particular unitary, but rather wish to learn the properties of the generator of the unitary.</span></span>
<span data-ttu-id="4e6e8-188">Por exemplo, em simulação quântica dinâmica, o objetivo é conceber circuitos quânticos que se aproximem de $U(t)=e^{-i H t}$ para uma matriz hermitiana $H$ e tempo de evolução $t$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-188">For example, in dynamical quantum simulation the goal is to devise quantum circuits that closely approximate $U(t)=e^{-i H t}$ for a Hermitian matrix $H$ and evolution time $t$.</span></span>
<span data-ttu-id="4e6e8-189">Os valores eigen de $U(t)$ estão diretamente relacionados com os valores eigen de $H$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-189">The eigenvalues of $U(t)$ are directly related to the eigenvalues of $H$.</span></span>
<span data-ttu-id="4e6e8-190">Para ver isto, considere um eigenvector de $H$: $H \ket{E} = E\ket{E}$ então é fácil de ver a partir da definição da série de potência da matriz exponencial que $U(t) \ket{E} = e^{i\phi}\ket{E}= e{-iEt}\ket{E}$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-190">To see this, consider an eigenvector of $H$: $H \ket{E} = E\ket{E}$ then it is easy to see from the power-series definition of the matrix exponential that $U(t) \ket{E} = e^{i\phi}\ket{E}= e^{-iEt}\ket{E}$.</span></span>
<span data-ttu-id="4e6e8-191">Assim, estimar a fase eigenphase de $U(t)$ dá o valor eigenvalue $E$ assumindo que o eigenvector $\ket{E}$ é a entrada no algoritmo de estimativa de fase.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-191">Thus estimating the eigenphase of $U(t)$ gives the eigenvalue $E$ assuming the eigenvector $\ket{E}$ is input into the phase estimation algorithm.</span></span>
<span data-ttu-id="4e6e8-192">No entanto, neste caso, o valor $t$ pode ser escolhido a critério do utilizador, uma vez que por qualquer valor suficientemente pequeno de $t$ o valor eigenvalue $E$ pode ser invertido exclusivamente através de $E=-\phi/t$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-192">However, in this case the value $t$ can be chosen at the user's discretion since for any sufficiently small value of $t$ the eigenvalue $E$ can be uniquely inverted through $E=-\phi/t$.</span></span>
<span data-ttu-id="4e6e8-193">Uma vez que os métodos de simulação quântica fornecem a capacidade de realizar uma evolução fracionária, esta concede aos algoritmos de estimativa de fase uma liberdade adicional ao consultar o unitário, especificamente enquanto o modelo de consulta discreta permite apenas unitários da forma $U^j$ para solicitar o inteiro $j$ o oráculo de consulta contínua permite-nos aproximar unitárias do formulário $U^t$ para qualquer $t de valor real.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-193">Since quantum simulation methods provide the ability to perform a fractional evolution, this grants phase estimation algorithms an additional freedom when querying the unitary, specifically while the discrete query model allows only unitaries of the form $U^j$ to applied for integer $j$ the continuous query oracle allows us to approximate unitaries of the form $U^t$ for any real valued $t$.</span></span>
<span data-ttu-id="4e6e8-194">Isto é importante para espremer cada gota de eficiência fora dos algoritmos de estimativa de fase, porque permite-nos escolher precisamente a experiência que forneceria mais informações sobre $E$; enquanto os métodos baseados em consultas discretas devem fazer com que se comprometa, escolhendo o melhor número inteiro de consultas no algoritmo.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-194">This is important to squeeze every last ounce of efficiency out of phase estimation algorithms because it allows us to choose precisely the experiment that would provide the most information about $E$; whereas methods based on discrete queries must make do with compromising by choosing the best integer number of queries in the algorithm.</span></span>

<span data-ttu-id="4e6e8-195">Como exemplo concreto disso, considere o problema de estimar não o ângulo de rotação de um portão, mas a frequência de procissão de um sistema quântico rotativo.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-195">As a concrete example of this, consider the problem of estimating not the rotation angle of a gate but the procession frequency of a rotating quantum system.</span></span>
<span data-ttu-id="4e6e8-196">O unitário que descreve tal dinâmica quântica é $U(t)=R_z(2\omega t)$ para o tempo de evolução $t$ e frequência desconhecida $\omega$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-196">The unitary that describes such quantum dynamics is $U(t)=R_z(2\omega t)$ for evolution time $t$ and unknown frequency $\omega$.</span></span>
<span data-ttu-id="4e6e8-197">Neste contexto, podemos simular $U(t)$ para qualquer $t$ usando um único portão $R_z$ e, como tal, não precisamos restringir-nos a penas discretas ao unitário.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-197">In this context, we can simulate $U(t)$ for any $t$ using a single $R_z$ gate and as such do not need to restrict ourselves to only discrete queries to the unitary.</span></span>
<span data-ttu-id="4e6e8-198">Um modelo tão contínuo também tem a propriedade que frequências superiores a $2\pi$ podem ser aprendidas a partir de processos de estimativa de fase que usam consultas contínuas porque informações de fase que de outra forma seriam mascaradas pelos cortes de ramos da função logarithm podem ser revelado a partir dos resultados de experiências realizadas em valores não-proporcionales de $t$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-198">Such a continuous model also has the property that frequencies greater than $2\pi$ can be learned from phase estimation processes that use continuous queries because phase information that would otherwise be masked by the branch-cuts of the logarithm function can be revealed from the results of experiments performed on non-commensurate values of $t$.</span></span>
<span data-ttu-id="4e6e8-199">Assim, para problemas como este modelo de consulta contínua para o oráculo de estimativa de fase não só são apropriados, mas também são preferíveis ao modelo de consulta discreta.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-199">Thus for problems such as this continuous query models for the phase estimation oracle are not only appropriate but are also preferable to the discrete query model.</span></span>
<span data-ttu-id="4e6e8-200">Por esta razão, q# tem funcionalidade para ambas as formas de consultas e deixa ao utilizador decidir sobre um algoritmo de estimativa de fase para se adaptar às suas necessidades e ao tipo de oráculo que está disponível.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-200">For this reason Q# has functionality for both forms of queries and leave it to the user to decide upon a phase estimation algorithm to fit their needs and the type of oracle that is available.</span></span>

## <a name="dynamical-generator-modeling"></a><span data-ttu-id="4e6e8-201">Modelação dinâmica do gerador</span><span class="sxs-lookup"><span data-stu-id="4e6e8-201">Dynamical Generator Modeling</span></span> ##

<span data-ttu-id="4e6e8-202">Geradores de evolução do tempo descrevem como os estados evoluem através do tempo.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-202">Generators of time-evolution describe how states evolve through time.</span></span> <span data-ttu-id="4e6e8-203">Por exemplo, a dinâmica de um estado quântico $\ket{\psi}$ é regida pela equação schrödinger $$ \begin {align} i\frac{d {\psi(t)}{d t} & = H \ket{\psi(t)}, \end{align} $$ com uma matriz hermitiana $H$, conhecida como o Hamiltonian, como o gerador do movimento.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-203">For instance, the dynamics of a quantum state $\ket{\psi}$ is governed by the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ with a Hermitian matrix $H$, known as the Hamiltonian, as the generator of motion.</span></span> <span data-ttu-id="4e6e8-204">Dado um estado inicial $\ket {\psi(0)}$ no momento $t=0$, a solução formal para esta equação no momento $t$ pode ser, em princípio, escrito $$ \start{ {align} \ket{\psi(t)} = U(t)\ket{\psi(0)}, \end{align} $$ onde a matriz exponencial $U(t)=e^{-i H t} operador unitário de evolução do tempo.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-204">Given an initial state $\ket{\psi(0)}$ at time $t=0$, the formal solution to this equation at time $t$ may be, in principle, written $$ \begin{align} \ket{\psi(t)} = U(t)\ket{\psi(0)}, \end{align} $$ where the matrix exponential $U(t)=e^{-i H t}$ is known as the unitary time-evolution operator.</span></span> <span data-ttu-id="4e6e8-205">Embora nos concentremos em geradores desta forma na seguinte forma, enfatizamos que o conceito se aplica mais amplamente, como a simulação de sistemas quânticos abertos, ou a equações diferenciais mais abstratas.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-205">Though we focus on generators of this form in the following, we emphasize that the concept applies more broadly, such as to the simulation of open quantum systems, or to more abstract differential equations.</span></span>

<span data-ttu-id="4e6e8-206">Um objetivo primário da simulação dinâmica é implementar o operador de evolução temporal em algum estado quântico codificado em qubits de um computador quântico.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-206">A primary goal of dynamical simulation is to implement the time-evolution operator on some quantum state encoded in qubits of a quantum computer.</span></span>  <span data-ttu-id="4e6e8-207">Em muitos casos, o Hamiltonian pode ser dividido numa soma de alguns termos $d$ mais simples</span><span class="sxs-lookup"><span data-stu-id="4e6e8-207">In many cases, the Hamiltonian may be broken into a sum of some $d$ simpler terms</span></span>

<span data-ttu-id="4e6e8-208">$$ \start{align} H & = \sum^{d-1}_{j=0} H_j, \end{align} $$</span><span class="sxs-lookup"><span data-stu-id="4e6e8-208">$$ \begin{align} H & = \sum^{d-1}_{j=0} H_j, \end{align} $$</span></span>

<span data-ttu-id="4e6e8-209">onde a evolução do tempo por si só é fácil de implementar num computador quântico.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-209">where time-evolution by each term alone is easy to implement on a quantum computer.</span></span> <span data-ttu-id="4e6e8-210">Por exemplo, se $H_j$ for um operador Pauli $X_1X_2$ que atua sobre os 1º e 2º elementos do registo qubit `qubits`, a evolução temporal por ele para qualquer momento $t$ pode ser implementado simplesmente chamando a operação `Exp([PauliX,PauliX], t, qubits[1..2])`, que tem assinatura `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-210">For instance, if $H_j$ is a Pauli $X_1X_2$ operator acting on the 1st and 2nd elements of the qubit register `qubits`, time-evolution by it for any time $t$ may be implemented simply by calling the operation `Exp([PauliX,PauliX], t, qubits[1..2])`, which has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span> <span data-ttu-id="4e6e8-211">Como discutido mais tarde na Simulação Hamiltoniana, uma solução é então aproximar a evolução do tempo em $H$ com uma sequência de operações mais simples</span><span class="sxs-lookup"><span data-stu-id="4e6e8-211">As discussed later in Hamiltonian Simulation, one solution then is to approximate time-evolution by $H$ with a sequence of simpler operations</span></span>

<span data-ttu-id="4e6e8-212">$$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right^{{r} + \mathcal{O}(d^\\max_j H\_j\\^2 t^2/r), \end{align} $$</span><span class="sxs-lookup"><span data-stu-id="4e6e8-212">$$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j \\|H\_j\\|^2 t^2/r), \end{align} $$</span></span>

<span data-ttu-id="4e6e8-213">onde o $r inteiro > 0$ controla o erro de aproximação.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-213">where the integer $r > 0$ controls the approximation error.</span></span>

<span data-ttu-id="4e6e8-214">A biblioteca dinâmica de modelação de geradores fornece um quadro para codificar sistematicamente geradores complicados em termos de geradores mais simples.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-214">The dynamical generator modeling library provides a framework for systematically encoding complicated generators in terms of simpler generators.</span></span> <span data-ttu-id="4e6e8-215">Tal descrição pode então ser passada para, digamos, a biblioteca de simulação para implementar a evolução do tempo através de um algoritmo de simulação de escolha, com muitos detalhes automaticamente tratados.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-215">Such a description may then be passed to, say, the simulation library to implement time-evolution by a simulation algorithm of choice, with many details automatically taken care of.</span></span>

> [!TIP]
> <span data-ttu-id="4e6e8-216">A biblioteca dinâmica do gerador descrita abaixo está coberta pelas amostras.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-216">The dynamical generator library described below is covered in the samples.</span></span> <span data-ttu-id="4e6e8-217">Para um exemplo baseado no modelo Ising, consulte a amostra [ **IsingGenerators** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/generators).</span><span class="sxs-lookup"><span data-stu-id="4e6e8-217">For an example based on the Ising model, please see the [**IsingGenerators** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/generators).</span></span>
> <span data-ttu-id="4e6e8-218">Para um exemplo baseado no hidrogénio molecular, consulte as amostras [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) e [**H2SimulationGUI.** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/gui)</span><span class="sxs-lookup"><span data-stu-id="4e6e8-218">For an example based on molecular Hydrogen, please see the [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) and [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/gui) samples.</span></span>

### <a name="complete-description-of-a-generator"></a><span data-ttu-id="4e6e8-219">Descrição completa de um gerador</span><span class="sxs-lookup"><span data-stu-id="4e6e8-219">Complete Description of a Generator</span></span> ###

<span data-ttu-id="4e6e8-220">Ao nível superior, uma descrição completa de um Hamiltonian está contida no tipo `EvolutionGenerator` definido pelo utilizador que tem dois componentes.:</span><span class="sxs-lookup"><span data-stu-id="4e6e8-220">At the top level, a complete description of a Hamiltonian is contained in the `EvolutionGenerator` user-defined type which has two components.:</span></span>

```qsharp
newtype EvolutionGenerator = (EvolutionSet, GeneratorSystem);
```

<span data-ttu-id="4e6e8-221">O `GeneratorSystem` tipo definido pelo utilizador é uma descrição clássica do Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-221">The `GeneratorSystem` user-defined type is a classical description of the Hamiltonian.</span></span>

```qsharp
newtype GeneratorSystem = (Int, (Int -> GeneratorIndex));
```

<span data-ttu-id="4e6e8-222">O primeiro elemento `Int` do tuple armazena o número de termos $d$ no Hamiltonian, e o segundo elemento `(Int -> GeneratorIndex)` é uma função que mapeia um índice inteiro em $\{0,1,...,d-1\}$ a um `GeneratorIndex` tipo definido pelo utilizador que identifica exclusivamente cada termo primitivo no Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-222">The first element `Int` of the tuple stores the number of terms $d$ in the Hamiltonian, and the second element `(Int -> GeneratorIndex)` is a function that maps an integer index in $\{0,1,...,d-1\}$ to a `GeneratorIndex` user-defined type which uniquely identifies each primitive term in the Hamiltonian.</span></span> <span data-ttu-id="4e6e8-223">Note-se que, expressando a coleção de termos no Hamiltonian como uma função e não como uma matriz `GeneratorIndex[]`, isto permite a computação on-the-fly do `GeneratorIndex` o que é especialmente útil ao descrever hamiltonianos com um grande número de termos.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-223">Note that by expressing the collection of terms in the Hamiltonian as a function rather than as an array `GeneratorIndex[]`, this allows for on-the-fly computation of the `GeneratorIndex` which is especially useful when describing Hamiltonians with a large number of terms.</span></span>

<span data-ttu-id="4e6e8-224">Fundamentalmente, não impomos uma convenção sobre os termos primitivos identificados pelos `GeneratorIndex` são fáceis de simular.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-224">Crucially, we do not impose a convention on what primitive terms identified by the `GeneratorIndex` are easy-to-simulate.</span></span> <span data-ttu-id="4e6e8-225">Por exemplo, os termos primitivos podem ser operadores pauli como discutido acima, mas também podem ser aniquilação fermiónica e operadores de criação comumente usados na simulação de química quântica.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-225">For instance, primitive terms could be Pauli operators as discussed above, but they could also be Fermionic annihilation and creation operators commonly used in quantum chemistry simulation.</span></span> <span data-ttu-id="4e6e8-226">Por si só, um `GeneratorIndex` não faz sentido, uma vez que não descreve como a evolução do tempo pelo termo que aponta pode ser implementada como um circuito quântico.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-226">By itself, a `GeneratorIndex` is meaningless as it does not describe how time-evolution by the term it points to may be implemented as a quantum circuit.</span></span>

<span data-ttu-id="4e6e8-227">Isto é resolvido especificando um `EvolutionSet` tipo definido pelo utilizador que mapeia qualquer `GeneratorIndex`, extraído de algum conjunto canónico, para um operador unitário, o `EvolutionUnitary`, expresso como circuito quântico.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-227">This is resolved by specifying an `EvolutionSet` user-defined type that maps any `GeneratorIndex`, drawn from some canonical set, to a unitary operator, the `EvolutionUnitary`, expressed as a quantum circuit.</span></span> <span data-ttu-id="4e6e8-228">O `EvolutionSet` define a convenção de como uma `GeneratorIndex` é estruturada, e também define o conjunto de possíveis `GeneratorIndex`.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-228">The `EvolutionSet` defines the convention of how a `GeneratorIndex` is structured, and also defines the set of possible `GeneratorIndex`.</span></span>

```qsharp
newtype EvolutionSet = (GeneratorIndex -> EvolutionUnitary);
```

### <a name="pauli-operator-generators"></a><span data-ttu-id="4e6e8-229">Geradores de operador pauli</span><span class="sxs-lookup"><span data-stu-id="4e6e8-229">Pauli Operator Generators</span></span> ###

<span data-ttu-id="4e6e8-230">Um exemplo concreto e útil de geradores são hamiltonianos que são uma soma de operadores Pauli, cada um possivelmente com um coeficiente diferente.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-230">A concrete and useful example of generators are Hamiltonians that are a sum of Pauli operators, each possibly with a different coefficient.</span></span>
<span data-ttu-id="4e6e8-231">$$ \start{align} H & = \sum^{d-1}_{j=0} a_j H_j, \end{align} $$ where each $\hat H_j$ is now drawn from the pauli group.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-231">$$ \begin{align} H & = \sum^{d-1}_{j=0} a_j H_j, \end{align} $$ where each $\hat H_j$ is now drawn from the Pauli group.</span></span> <span data-ttu-id="4e6e8-232">Para estes sistemas, fornecemos a `PauliEvolutionSet()` de tipo `EvolutionSet` que define uma convenção de como um elemento do grupo Pauli e um coeficiente podem ser identificados por um `GeneratorIndex`, que tem a seguinte assinatura.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-232">For such systems, we provide the `PauliEvolutionSet()` of type `EvolutionSet` that defines a convention for how an element of the Pauli group and a coefficient may be identified by a `GeneratorIndex`, which has the following signature.</span></span>

```qsharp
newtype GeneratorIndex = ((Int[], Double[]), Int[]);
```

<span data-ttu-id="4e6e8-233">Na nossa codificação, o primeiro parâmetro `Int[]` especifica uma corda Pauli, onde $\hat I\hat I\rightarrow 0$, $\hat X\rightarrow 1$, $hat Y\rightarrow 2$, e $\hat Z\rightarrow 3$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-233">In our encoding, the first parameter `Int[]` specifies a Pauli string, where $\hat I\rightarrow 0$, $\hat X\rightarrow 1$, $\hat Y\rightarrow 2$, and $\hat Z\rightarrow 3$.</span></span> <span data-ttu-id="4e6e8-234">O segundo parâmetro `Double[]` armazena o coeficiente da corda Pauli no Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-234">The second parameter `Double[]` stores the coefficient of the Pauli string in the Hamiltonian.</span></span> <span data-ttu-id="4e6e8-235">Note que apenas o primeiro elemento desta matriz é utilizado.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-235">Note that only the first element of this array is used.</span></span> <span data-ttu-id="4e6e8-236">O terceiro parâmetro `Int[]` indexa os qubits em que esta corda Pauli age, e não deve ter elementos duplicados.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-236">The third parameter `Int[]` indexes the qubits that this Pauli string acts on, and must have no duplicate elements.</span></span> <span data-ttu-id="4e6e8-237">Assim, o termo Hamiltonian $0.4 \hat X_0 \hat Y_8\hat I_2\hat Z_1$ pode ser representado como</span><span class="sxs-lookup"><span data-stu-id="4e6e8-237">Thus the Hamiltonian term $0.4 \hat X_0 \hat Y_8\hat I_2\hat Z_1$ may be represented as</span></span>

```qsharp
let generatorIndexExample = GeneratorIndex(([1,2,0,3], [0.4]]), [0,8,2,1]);
```

<span data-ttu-id="4e6e8-238">O `PauliEvolutionSet()` é uma função que mapeia qualquer `GeneratorIndex` deste formulário para um `EvolutionUnitary` com a seguinte assinatura.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-238">The `PauliEvolutionSet()` is a function that maps any `GeneratorIndex` of this form to an `EvolutionUnitary` with the following signature.</span></span>

```qsharp
newtype EvolutionUnitary = ((Double, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="4e6e8-239">O primeiro parâmetro representa uma duração temporal, que será multiplicada pelo coeficiente no `GeneratorIndex`, da evolução unitária.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-239">The first parameter represents a time-duration, that will be multiplied by the coefficient in the `GeneratorIndex`, of unitary evolution.</span></span> <span data-ttu-id="4e6e8-240">O segundo parâmetro é o registo qubit em que os atos unitários se baseiam.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-240">The second parameter is the qubit register the unitary acts on.</span></span> 

### <a name="time-dependent-generators"></a><span data-ttu-id="4e6e8-241">Geradores dependentes do tempo</span><span class="sxs-lookup"><span data-stu-id="4e6e8-241">Time-Dependent Generators</span></span> ###

<span data-ttu-id="4e6e8-242">Em muitos casos, também estamos interessados em modelar geradores dependentes do tempo, como pode ocorrer na equação de Schrödinger $$ \begin {align} i\frac{d {\psi(t)}}{d t} & = \hat H(t) \ket{\psi(t)}, \end{align} $} onde o gerador $\Hat(t)$ é agora dependente do tempo.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-242">In many cases, we are also interested in modelling time-dependent generators, as might occur in the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = \hat H(t) \ket{\psi(t)}, \end{align} $$ where the generator $\hat H(t)$ is now time-dependent.</span></span> <span data-ttu-id="4e6e8-243">A extensão dos geradores independentes do tempo para este caso é simples.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-243">The extension from the time-independent generators above to this case is straightforward.</span></span> <span data-ttu-id="4e6e8-244">Em vez de termos um `GeneratorSystem` fixo descrevendo o Hamiltonian para todos os momentos $t$, em vez disso temos o `GeneratorSystemTimeDependent` tipo definido pelo utilizador.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-244">Rather than having a fixed `GeneratorSystem` describing the Hamiltonian for all times $t$, we instead have the `GeneratorSystemTimeDependent` user-defined type.</span></span>

```qsharp
newtype GeneratorSystemTimeDependent = (Double -> GeneratorSystem);
```

<span data-ttu-id="4e6e8-245">O primeiro parâmetro é um parâmetro de horário contínuo $s\in [0,1]$, e funções deste tipo devolvem um `GeneratorSystem` para esse horário.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-245">The first parameter is a continuous schedule parameter $s\in [0,1]$, and functions of this type return a `GeneratorSystem` for that schedule.</span></span> <span data-ttu-id="4e6e8-246">Note que o parâmetro de horário pode estar linearmente relacionado com o parâmetro do tempo físico, por exemplo, $s = t / T$, durante algum tempo total de simulação $T$.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-246">Note that the schedule parameter may be linearly related to the physical time parameter e.g. $s = t / T$, for some total time of simulation $T$.</span></span> <span data-ttu-id="4e6e8-247">No entanto, em geral, não é necessário.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-247">In general however, this need not be the case.</span></span>

<span data-ttu-id="4e6e8-248">Da mesma forma, uma descrição completa deste gerador requer uma `EvolutionSet`, e por isso definimos um tipo `EvolutionSchedule` definido pelo utilizador.</span><span class="sxs-lookup"><span data-stu-id="4e6e8-248">Similarly, a complete description of this generator requires an `EvolutionSet`, and so we define an `EvolutionSchedule` user-defined type.</span></span>

```qsharp
newtype EvolutionSchedule = (EvolutionSet, GeneratorSystemTimeDependent);
```
