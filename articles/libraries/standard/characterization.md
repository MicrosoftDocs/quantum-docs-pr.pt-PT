---
title: Caracterização quântica e estatísticas
description: Saiba como as estatísticas de medição das estimativas de fase são usadas para estimar os valores dos resultados na programação quântica.
author: QuantumWriter
uid: microsoft.quantum.libraries.characterization
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 7ed92c29020ccf389faa099f5bd80516af525578
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: pt-PT
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907193"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="dd9fe-103">Caracterização quântica e Estatísticas</span><span class="sxs-lookup"><span data-stu-id="dd9fe-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="dd9fe-104">É fundamental ser capaz de caracterizar os efeitos das operações de forma a desenvolver algoritmos quânticos úteis.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="dd9fe-105">Isto é um desafio porque cada medição de um sistema quântico produz, no máximo, um pouco de informação.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="dd9fe-106">Para aprender um eigenvalue, muito menos um estado quântico, os resultados de muitas medições devem ser costurados em conjunto para que o utilizador possa recolher os muitos pedaços de informação necessários para representar estes conceitos.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="dd9fe-107">Os Estados quânticos são especialmente preocupantes porque o [teorema](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) de não clonagem afirma que não há forma de aprender um estado quântico arbitrário a partir de uma única cópia do Estado, porque fazê-lo permitiria fazer cópias do Estado.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="dd9fe-108">Esta obfuscção do estado quântico do utilizador reflete-se no facto de q# não expor ou mesmo definir o que um estado *é* para programas quânticos.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-108">This obfuscation of the quantum state from the user is reflected in the fact that Q# does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="dd9fe-109">Abordamos assim a caracterização quântica, tratando as operações e os Estados como caixa preta; esta abordagem partilha muito em comum com a prática experimental de caracterização quântica, verificação e validação (QCVV).</span><span class="sxs-lookup"><span data-stu-id="dd9fe-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="dd9fe-110">A caracterização é distinta de muitas das outras bibliotecas discutidas anteriormente.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="dd9fe-111">O objetivo aqui é menos aprender informação clássica sobre o sistema, em vez de realizar uma transformação unitária num vetor de estado.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="dd9fe-112">Estas bibliotecas devem, portanto, misturar o processamento de informação clássica e quântica.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="dd9fe-113">Estimativa da fase iterativa</span><span class="sxs-lookup"><span data-stu-id="dd9fe-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="dd9fe-114">Ver a programação quântica em termos de caracterização quântica sugere uma alternativa útil à estimativa da fase quântica.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="dd9fe-115">Ou seja, em vez de preparar mossa $n registo de qubit para conter uma representação binária da fase como na estimativa da fase quântica, podemos ver a estimativa de fase como o processo pelo qual um agente *clássico* aprende propriedades de um sistema quântico através de medições.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="dd9fe-116">Procedemos como no caso quântico usando o recuo de fase para transformar as aplicações de uma operação de caixa preta em rotações por um ângulo desconhecido, mas vamos medir o qubit de oscilação que giramos em cada passo imediatamente após a rotação.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="dd9fe-117">Isto tem a vantagem de que só precisamos de um único qubit adicional para realizar o recuo de fase descrito no caso quântico, pois aprendemos então a fase a partir dos resultados de medição em cada passo de forma iterativa.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="dd9fe-118">Cada um dos métodos abaixo propostos utiliza uma estratégia diferente para conceber experiências e diferentes métodos de processamento de dados para aprender a fase.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="dd9fe-119">Cada um deles tem uma vantagem única que vai desde ter rigorosos limites de erro, até as capacidades de incorporar informações prévias, tolerar erros ou executar em computadores clássicos limitados de memória.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="dd9fe-120">Ao discutir a estimativa da fase iterativa, consideraremos um $U$ unitário dado como uma operação de caixa preta.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="dd9fe-121">Tal como descrito na secção sobre oráculos em estruturas de [dados,](xref:microsoft.quantum.libraries.data-structures)os modelos canon Q# tais operações pelo <xref:microsoft.quantum.oracles.discreteoracle> tipo definido pelo utilizador, definidos pelo tipo tuple `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the Q# canon models such operations by the <xref:microsoft.quantum.oracles.discreteoracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="dd9fe-122">Concretamente, se `U : DiscreteOracle`, então `U(m)` implementa $U^m$ para `m : Int`.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="dd9fe-123">Com esta definição em vigor, cada passo da estimativa da fase iterativa prossegue preparando um qubit auxiliar no estado $\ket{+}$ juntamente com o estado inicial $\ket {\phi}} que assumimos ser um [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) de $U(m)$, ou seja, $U(m)\ket{\phi}= e^im\phi}\ket{}}}.}.}.}.}.}.}.}.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxiliary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="dd9fe-124">Uma aplicação controlada de `U(m)` é então usada que prepara o estado $\left (R\_1(m \phi) \ket{+}\right)ket{\phi}$.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="dd9fe-125">Tal como no caso quântico, o efeito de uma aplicação controlada do oráculo `U(m)` é precisamente o mesmo que o efeito de aplicar $R_1$ para a fase desconhecida em $\ket{+}$, de tal forma que podemos descrever os efeitos de $U$ desta forma mais simples.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="dd9fe-126">Opcionalmente, o algoritmo roda o qubit de controlo aplicando $R_1 (-m\theta)$ para obter um estado $\ket{\psi}=à esquerda(R\_1(m [\phi-\theta]) \ket{+}\direita)\ket{\phi}$.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="dd9fe-127">O qubit auxiliar utilizado como controlo para `U(m)` é então medido na base $X$para obter uma única `Result`clássica.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-127">The auxiliary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="dd9fe-128">Neste ponto, a reconstrução da fase a partir dos valores `Result` obtidos através da estimativa da fase iterativa é um problema clássico de inferência estatística.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="dd9fe-129">Encontrar o valor de $m$ que maximize a informação obtida, dado um método de inferência fixa, é simplesmente um problema nas estatísticas.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="dd9fe-130">Salientamos isto descrevendo brevemente a estimativa da fase iterativa a nível teórico no formalismo de estimativa do parâmetro bayesiano antes de proceder para descrever os algoritmos estatísticos fornecidos no cânone Q# para resolver este problema de inferência clássica.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the Q# canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="dd9fe-131">Estimativa de fase iterativa sem eigenstates</span><span class="sxs-lookup"><span data-stu-id="dd9fe-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="dd9fe-132">Se for fornecido um estado de entrada que não seja um eigenstate, o que significa que se $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ então o processo de estimativa de fase não-determinicamente guia o estado quântico para um único eigenstate energético.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="dd9fe-133">O eigenstate a que, em última análise, converge é o eigenstate que é mais provável produzir o `Result`observado.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="dd9fe-134">Especificamente, um único passo de E executa a seguinte transformação não unitária num estado \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}\phi\_j)}}</span><span class="sxs-lookup"><span data-stu-id="dd9fe-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}.</span></span>
<span data-ttu-id="dd9fe-135">\end{align} Como este processo é iterado sobre vários valores de `Result`, os eigenstates que não têm valores máximos de $\prod_k\Pr(\text{Result}\_k\phi\_j)$ serão exponencialmente suprimidos.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="dd9fe-136">Como resultado, o processo de inferência tenderá a convergir para estados com um único eigenvalue se as experiências forem escolhidas corretamente.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="dd9fe-137">O teorema de Bayes sugere ainda que o estado que resulta da estimativa de fase seja escrito na forma \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}\phi\_j)}\ket{\\_phi j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}\phi\_j)}\\sum_j\\\sqrt{\Pr(\phi\_j\text{Result}}} \ket{\phi\_j}.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="dd9fe-138">\end{align} Here $\Pr(\phi\_j\text{Result})$pode ser interpretado como a probabilidade que se atribuiria a cada hipótese sobre os eigenstates dado:</span><span class="sxs-lookup"><span data-stu-id="dd9fe-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="dd9fe-139">conhecimento do estado quântico antes da medição,</span><span class="sxs-lookup"><span data-stu-id="dd9fe-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="dd9fe-140">conhecimento dos eigenstates de $U$ e,</span><span class="sxs-lookup"><span data-stu-id="dd9fe-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="dd9fe-141">conhecimento dos valores eigen de $U$.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="dd9fe-142">Aprender estas três coisas é muitas vezes exponencialmente difícil num computador clássico.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="dd9fe-143">A utilidade da estimativa de fase surge, em grande parte, pelo facto de poder realizar uma tarefa de aprendizagem quântica sem conhecer nenhuma delas.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="dd9fe-144">A estimativa de fase por esta razão aparece dentro de uma série de algoritmos quânticos que fornecem acelerações exponenciais.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="dd9fe-145">Estimativa da fase bayesiana</span><span class="sxs-lookup"><span data-stu-id="dd9fe-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="dd9fe-146">Para obter mais detalhes sobre a estimativa da fase bayesiana na prática, consulte a amostra de Estimativa de [**Fase.** ](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation)</span><span class="sxs-lookup"><span data-stu-id="dd9fe-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="dd9fe-147">A ideia da estimativa da fase bayesiana é simples.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="dd9fe-148">Recolhe-se estatísticas de medição do protocolo de estimativa de fase e, em seguida, processa os resultados usando inferência bayesiana e fornece uma estimativa do parâmetro.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="dd9fe-149">Este processamento dá-lhe uma estimativa do valor eigenvalue, bem como da incerteza nessa estimativa.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="dd9fe-150">Também permite realizar experiências adapttivas e utilizar informações prévias.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="dd9fe-151">O principal inconveniente dos métodos é que é computacionalmente exigente.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="dd9fe-152">Para entender como funciona este processo de inferência bayesiana, considere o caso de processamento de um único resultado `Zero`.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="dd9fe-153">Note que $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, de tal forma que $\ket{+}$ é o único eigenstate positivo de $X$ correspondente a `Zero`.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="dd9fe-154">A probabilidade de observar `Zero` para uma [medição`PauliX`](xref:microsoft.quantum.concepts.pauli) no primeiro qubit dado um estado de entrada {\cet{\psi}\ket{\phi}$ é assim \start{equation} \Pr(\texttt{{ { \ psi) = \left; \braket{+ \ \psi} \right^2.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="dd9fe-155">\end{equation} No caso da estimativa da fase iterativa, temos aquele $\ket{\psi} = R_1(m [\phi-theta]) \ket{+}$, de tal forma que \start{align} \Pr(\texttt{Zero} \ \phi; m,\theta) & = \left \braket{+ [ R_1 (m[\phi-\theta]) [ +} \direita^^^2 \\\\ & = \left; \frac12 \left, \bra{0} + \bra{1} \right, \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right; \right^2 \\\\ & = \left; \frac{1 + e^{i m [\phi-\theta]}}{2} \right\^\\2 \\ & = \cos^2(m [\phi-theta] / 2) \tag{★} \label{eq:phase-est-probabilidade}.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="dd9fe-156">\end{align} Ou seja, a estimativa da fase iterativa consiste em aprender a frequência de oscilação de uma função sinusoidal, dada a capacidade de lançar uma moeda com um enviesamento dado por esse sinusoid.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="dd9fe-157">Seguindo a terminologia clássica tradicional, chamamos $\eqref{eq:phase-est-probabilidade}$ a *função de probabilidade* para estimativa de fase iterativa.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="dd9fe-158">Tendo observado uma `Result` da função de probabilidade de estimativa de fase iterativa, podemos então usar a regra de Bayes para prescrever o que devemos acreditar que a fase deve seguir essa observação.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="dd9fe-159">Concretamente, \start{equation} \Pr(\phi  d) = \frac{\Pr(d  \phi) \Pr(\phi){\int \Pr(d  \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} onde $d \in \\{\textt{Zero}, \texttt{One}\\}$ é um `Result`, e onde $\Pr(\phi)$ descreve as nossas crenças anteriores sobre $\phi$.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="dd9fe-160">Isto torna então explícita a natureza iterativa da estimativa da fase iterativa, uma vez que a distribuição posterior $\Pr(\phi / d)$ descreve as nossas crenças imediatamente antes da nossa observação da próxima `Result`.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceding our observation of the next `Result`.</span></span>

<span data-ttu-id="dd9fe-161">Em qualquer momento durante este procedimento, podemos reportar a fase $\hat{\phi}$ inferida pelo controlador clássico como \start{equation} \hat{\phi \mathrel{:=} \expect[\phi ] \text{data}] = \int \phi \Pr(\phi [ \text{data}) {\mathrm d}\phi, \end{equação} onde o texto {{data}`Result`}</span><span class="sxs-lookup"><span data-stu-id="dd9fe-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="dd9fe-162">A inferência exata de Bayesian é na prática intratável.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="dd9fe-163">Para ver esta imagine, queremos aprender uma variável de $n$bit $x$.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="dd9fe-164">A distribuição prévia $\Pr(x)$ tem suporte acima de $2^n$ valores hipotéticos de $x$.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="dd9fe-165">Isto significa que se precisarmos de uma estimativa muito precisa de $x$ então a estimativa da fase bayesiana pode precisar de memória proibitiva e tempo de processamento.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="dd9fe-166">Embora para algumas aplicações, como a simulação quântica, a precisão limitada necessária não impeça tais métodos de outras aplicações, como o algoritmo de Shor, não podem usar a inferência bayesiana exata dentro do seu passo de estimativa de fase.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="dd9fe-167">Por esta razão, também fornecemos implementações para métodos bayesianos aproximados, tais como a estimativa de [fases de caminhada aleatória (RWPE)](xref:microsoft.quantum.research.randomwalkphaseestimation.randomwalkphaseestimation) e também abordagens não bayesianas, tais como [a estimativa de fase robusta.](xref:microsoft.quantum.characterization.robustphaseestimation)</span><span class="sxs-lookup"><span data-stu-id="dd9fe-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:microsoft.quantum.research.randomwalkphaseestimation.randomwalkphaseestimation) and also non-Bayesian approaches such as [robust phase estimation](xref:microsoft.quantum.characterization.robustphaseestimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="dd9fe-168">Estimativa de fase robusta</span><span class="sxs-lookup"><span data-stu-id="dd9fe-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="dd9fe-169">Um máximo uma reconstrução *posteriori* Bayesian de uma estimativa de fase dos resultados da medição é exponencialmente difícil no pior dos casos.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="dd9fe-170">Assim, a maioria dos algoritmos práticos de estimativa de fase sacrificam alguma qualidade na reconstrução, em troca de uma quantidade de pós-processamento clássico que, em vez disso, escala polinomialmente com o número de medições feitas.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="dd9fe-171">Um desses exemplos com um passo pós-processamento clássico eficiente é o algoritmo robusto de estimativa de [fase,](https://arxiv.org/abs/1502.02677)com a sua assinatura e inputs acima mencionados.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="dd9fe-172">Assume que as caixas pretas unitárias de entrada $U$ são embaladas como `DiscreteOracle` tipo, e, portanto, apenas consultas de $U$controladas.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="dd9fe-173">Se o estado de entrada no registo `Qubit[]` for um eigenstate $U\ket{\psi}=e^{i\phi\ket{\psi}$, o algoritmo de estimativa de fase robusta devolve uma estimativa $\hat{\phi}\in[-\pi,\pi)$ de $\phi$ como um `Double`.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="dd9fe-174">A característica mais importante da estimativa de fase robusta, que é partilhada com a maioria das outras variantes úteis, é que a qualidade de reconstrução de $\hat{\phi}$ é, de certa forma, limitada a Heisenberg.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="dd9fe-175">Isto significa que se o desvio de $\hat{\phi}$ do valor real for $\sigma$, então $\sigma$ escalas inversamente-proporcionais ao número total de consultas $Q$ feitas a $U$, ou seja, $\sigma=\mathcal{O}(1/Q)$.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="dd9fe-176">Agora, a definição de desvio varia entre diferentes algoritmos de estimativa.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="dd9fe-177">Em alguns casos, pode significar que com pelo menos $\mathcal{O}(1)$ probabilidade, o erro de estimativa $\hat{\phi}-\phi\_\circ\le \sigma$ em alguma medida circular $\circ$.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="dd9fe-178">Para uma estimativa robusta da fase, o desvio é precisamente a variação $\sigma^2 = \mathbb{E}\_\hat{\phi}[[\mod\_{2\pi}(\hat{\phi}\phi +\pi)-pi)^2]$ se desembrulharmos as fases periódicas num único intervalo finito $(\pi,pi]$.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="dd9fe-179">Mais precisamente, o desvio padrão na estimativa de fase robusta satisfaz as desigualdades $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ onde o limite inferior é atingido no limite de assimptoticamente grande $Q$, e o limite superior é garantido mesmo para pequenas amostras.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="dd9fe-180">Note que $n$ selecionados pela entrada `bitsPrecision`, que define implicitamente $Q$.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="dd9fe-181">Outros detalhes relevantes incluem, por exemplo, o pequeno espaço sobrecarga de apenas $1$ qubit de acesso, ou que o procedimento não é adaptável, o que significa que a sequência necessária de experiências quânticas é independente dos resultados de medição intermédio.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="dd9fe-182">Neste e próximo exemplos em que a escolha do algoritmo de estimativa de fase é importante, deve-se referir-se à documentação, como @"microsoft.quantum.characterization.robustphaseestimation" e às publicações referenciadas para obter mais informações e para a sua implementação.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.characterization.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="dd9fe-183">Há muitas amostras onde é utilizada uma estimativa de fase robusta.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="dd9fe-184">Para a estimativa de fase na extração da energia do estado terrestre de vários sistemas físicos, consulte a amostra de [ **simulação H2,** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line)a amostra [ **simpleising** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/simple)e a amostra do [ **modelo Hubbard.** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/hubbard)</span><span class="sxs-lookup"><span data-stu-id="dd9fe-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="dd9fe-185">Oráculos contínuos</span><span class="sxs-lookup"><span data-stu-id="dd9fe-185">Continuous Oracles</span></span> ###

<span data-ttu-id="dd9fe-186">Também podemos generalizar a partir do modelo oráculo usado acima para permitir oráculos de tempo contínuo, modelados pelo tipo canon <xref:microsoft.quantum.oracles.continuousoracle>.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:microsoft.quantum.oracles.continuousoracle>.</span></span>
<span data-ttu-id="dd9fe-187">Considere que em vez de um único operador unitário $U$, temos uma família de operadores unitários $U(t)$ para $t \in \mathbb{R}$ tal que $U(t) U(s)$ = $U(t+ s)$.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="dd9fe-188">Esta é uma afirmação mais fraca do que no caso discreto, uma vez que podemos construir uma <xref:microsoft.quantum.oracles.discreteoracle> restringindo $t = m\,\delta t$ por alguns $\delta t$fixos.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-188">This is a weaker statement than in the discrete case, since we can construct a <xref:microsoft.quantum.oracles.discreteoracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="dd9fe-189">Pelo [teorema de Stone](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ para algum operador $H$, onde $\exp$ é a matriz exponencial como descrito em [matriz avançada.](xref:microsoft.quantum.concepts.matrix-advanced)</span><span class="sxs-lookup"><span data-stu-id="dd9fe-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="dd9fe-190">Um eigenstate $\ket {\phi}$ de $H$ tal que $H \ket{\phi} = \phi {\phi}} é então também um eigenstate de $U(t)$ para todos os $t$, \start{equation} U(t) \ket{\phi} = e{^i \phi t} \{\phi}.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="dd9fe-191">\end{equation}</span><span class="sxs-lookup"><span data-stu-id="dd9fe-191">\end{equation}</span></span>

<span data-ttu-id="dd9fe-192">A mesma análise discutida para a estimativa da [fase bayesiana](#bayesian-phase-estimation) pode ser aplicada, e a função de probabilidade é precisamente a mesma para este modelo oráculo mais geral: $$ \Pr(\texttt{Zero} \ phi; t,\theta)=\cos^2\left (\frac{t[\phi -\theta]}{2}\direita).</span><span class="sxs-lookup"><span data-stu-id="dd9fe-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="dd9fe-193">$$ Além disso, se $U$ é uma simulação de um gerador dinâmico, como é o caso da [simulação hamiltoniana,](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation)interpretamos $\phi$ como uma energia.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="dd9fe-194">Assim, usar a estimativa de fase com consultas contínuas permite-nos aprender o espectro de energia simulado [de moléculas,](https://arxiv.org/abs/quant-ph/0604193) [materiais](https://arxiv.org/abs/1510.03859) ou [teorias](https://arxiv.org/abs/1111.3633v2) de campo sem ter que comprometer a nossa escolha de experiências, exigindo que $t$ seja um inteiro.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="dd9fe-195">Estimativa de fase de caminhada aleatória</span><span class="sxs-lookup"><span data-stu-id="dd9fe-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="dd9fe-196">Q# fornece uma aproximação útil da estimativa de fase bayesiana projetada para uso perto de dispositivos quânticos que operam condicionando uma caminhada aleatória no registo de dados obtido a partir da estimativa de fase iterativa.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-196">Q# provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="dd9fe-197">Este método é simultaneamente adaptativo e inteiramente determinista, permitindo uma escala quase ótima de erros na fase estimada $\hat{\phi}$ com despesas de memória muito baixas.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="dd9fe-198">O protocolo usa um método de inferência bayesiana aproximada que pressupõe que a distribuição prévia é gaussian.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="dd9fe-199">Esta suposição gaussiana permite-nos usar uma fórmula analítica para a experiência que minimiza a variação posterior.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="dd9fe-200">O algoritmo, então, com base no resultado dessa experiência, muda a estimativa de $\phi$ à esquerda ou à direita por uma quantia pré-determinada e diminui a variação por uma quantia pré-determinada.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="dd9fe-201">Esta média e variação dão toda a informação necessária para especificar um gaussiano anterior em $\phi$ para a próxima experiência.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="dd9fe-202">Falhas de medição inesperadas, ou o resultado real estar na cauda do anterior inicial, podem fazer com que este método falhe.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="dd9fe-203">Recupera-se da falha através da realização de experiências para testar se a média atual e o desvio padrão são adequados para o sistema.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="dd9fe-204">Se não forem, então o algoritmo faz um passo inverso da caminhada e o processo continua.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="dd9fe-205">A capacidade de andar para trás também permite que o algoritmo aprenda mesmo que o desvio padrão inicial seja inapropriadamente pequeno.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="dd9fe-206">Algoritmos de estimativa de fase</span><span class="sxs-lookup"><span data-stu-id="dd9fe-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="dd9fe-207">Cada operação de estimativa de fase fornecida com o cânon Q# leva um conjunto diferente de inputs parametrizando a qualidade que exigimos da estimativa final $\hat{\phi}$.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-207">Each phase estimation operation provided with the Q# canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="dd9fe-208">Estas várias inputs, no entanto, todas partilham várias inputs em comum, de tal forma que a aplicação parcial sobre os parâmetros de qualidade resulta numa assinatura comum.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="dd9fe-209">Por exemplo, a operação <xref:microsoft.quantum.characterization.robustphaseestimation> discutida na secção seguinte tem a seguinte assinatura:</span><span class="sxs-lookup"><span data-stu-id="dd9fe-209">For example, the <xref:microsoft.quantum.characterization.robustphaseestimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="dd9fe-210">A entrada `bitsPrecision` é única para `RobustPhaseEstimation`, enquanto `oracle` e `eigenstate` são comuns.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="dd9fe-211">Assim, como visto no **H2Sample,** uma operação pode aceitar um algoritmo de estimativa de fase iterativa com uma entrada do formulário `(DiscreteOracle, Qubit[]) => Unit` permitir que um utilizador especifique algoritmos de estimativa de fase arbitrária:</span><span class="sxs-lookup"><span data-stu-id="dd9fe-211">Thus, as seen in **H2Sample**, an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

<span data-ttu-id="dd9fe-212">Estes algoritmos de estimativa de fase miríade são otimizados para diferentes propriedades e parâmetros de entrada, que devem ser entendidos para fazer a melhor escolha para a aplicação alvo.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="dd9fe-213">Por exemplo, alguns algoritmos de estimativa de fase são adaptáveis, o que significa que os passos futuros são controlados clássicamente pelos resultados de medição de passos anteriores.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="dd9fe-214">Alguns requerem a capacidade de exponenciar o seu oráculo unitário caixa preta por poderes reais arbitrários, e outros apenas requerem poderes inteiros, mas só são capazes de resolver uma estimativa de fase modulo $2\pi$.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="dd9fe-215">Alguns requerem muitos qubits auxiliares, e outros requerem apenas um.</span><span class="sxs-lookup"><span data-stu-id="dd9fe-215">Some require many auxiliary qubits, and others require only one.</span></span>

<span data-ttu-id="dd9fe-216">Da mesma forma, a utilização da estimativa de fase de caminhada aleatória prossegue da mesma forma que para outros algoritmos fornecidos com o cânone:</span><span class="sxs-lookup"><span data-stu-id="dd9fe-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
