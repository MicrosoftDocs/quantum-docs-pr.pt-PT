---
title: 'Algoritmos quânticos em Q #'
description: Aprenda sobre algoritmos fundamentais de computação quântica, incluindo amplificação de amplitude, fourier transform, draper e beauregard adders, e estimativa de fase.
author: QuantumWriter
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
ms.openlocfilehash: 8b8a9019e8bc419f42b0c6f7558354d19a157917
ms.sourcegitcommit: d61b388651351e5abd4bfe7a672e88b84a6697f8
ms.translationtype: MT
ms.contentlocale: pt-PT
ms.lasthandoff: 03/15/2020
ms.locfileid: "79402855"
---
# <a name="quantum-algorithms"></a><span data-ttu-id="0bf0a-103">Algoritmos Quânticos</span><span class="sxs-lookup"><span data-stu-id="0bf0a-103">Quantum Algorithms</span></span> #

## <a name="amplitude-amplification"></a><span data-ttu-id="0bf0a-104">Amplificação de Amplitude</span><span class="sxs-lookup"><span data-stu-id="0bf0a-104">Amplitude Amplification</span></span> ##

<span data-ttu-id="0bf0a-105">*A Amplificação amplitude* é uma das ferramentas fundamentais da Computação Quântica.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-105">*Amplitude Amplification* is one of the fundamental tools of Quantum Computing.</span></span> <span data-ttu-id="0bf0a-106">É a ideia fundamental que está subjacente à pesquisa, estimativa de amplitude de Grover e muitos algoritmos de aprendizagem automática quântica.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-106">It is the fundamental idea that underlies Grover's search, amplitude estimation and many quantum machine learning algorithms.</span></span>  <span data-ttu-id="0bf0a-107">Existem muitas variantes, e em Q# fornecemos uma versão geral baseada na Amplificação de Amplitude Alheia com Reflexões Parciais para permitir a maior área de aplicação.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-107">There are many variants, and in Q# we provide a general version based on Oblivious Amplitude Amplification with Partial Reflections to allow for the widest area of application.</span></span>

<span data-ttu-id="0bf0a-108">A ideia central por trás da amplificação da amplitude é amplificar a probabilidade de um resultado desejado ocorrer através da realização de uma sequência de reflexões.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-108">The central idea behind amplitude amplification is to amplify the probability of a desired outcome occurring by performing a sequence of reflections.</span></span>  <span data-ttu-id="0bf0a-109">Estas reflexões giram o estado inicial mais próximo de um estado-alvo desejado, muitas vezes chamado de estado marcado.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-109">These reflections rotate the initial state closer towards a desired target state, often called a marked state.</span></span>  <span data-ttu-id="0bf0a-110">Especificamente, se a probabilidade de medir o estado inicial para estar em estado marcado é $\sin^2(\theta)$ então depois de aplicar amplificação de amplitude $m$ vezes a probabilidade de sucesso se torna $\sin^2 ((2m+1)\theta)$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-110">Specifically, if the probability of measuring the initial state to be in a marked state is $\sin^2(\theta)$ then after applying amplitude amplification $m$ times the probability of success becomes $\sin^2((2m+1)\theta)$.</span></span>  <span data-ttu-id="0bf0a-111">Isto significa que se $\theta = \pi/[2(2n+1)] $ por algum valor de $n$ então a amplificação amplitude é capaz de aumentar a probabilidade de sucesso para $100\\%$ após $n de iterações de amplificação amplitude.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-111">This means that if $\theta = \pi/[2(2n+1)]$ for some value of $n$ then amplitude amplification is capable of boosting the probability of success to $100\\%$ after $n$ iterations of amplitude amplification.</span></span>  <span data-ttu-id="0bf0a-112">Uma vez que $\teta = \sin^{-1}(\sqrt{\Pr(sucesso)}}}$isto significa que o número de iterações necessárias para obter um sucesso determinicamente é quadraticamente inferior ao número esperado necessário para encontrar um estado marcado não determinicamente usando amostras aleatórias.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-112">Since $\theta = \sin^{-1}(\sqrt{\Pr(success)})$ this means that the number of iterations needed to obtain a success deterministically is quadratically lower than the expected number needed to find a marked state non-deterministically using random sampling.</span></span>

<span data-ttu-id="0bf0a-113">Cada iteração da amplificação amplitude requer que sejam especificados dois operadores de reflexão.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-113">Each iteration of Amplitude amplification requires that two reflection operators be specified.</span></span> <span data-ttu-id="0bf0a-114">Especificamente, se $Q$ é o iterato de amplificação amplitude e $P_0$ é um operador de projetor no subespaço inicial e $P_1$ é o projetor sobre o subespaço marcado e ntão $Q=-(\boldone-2P_0)(\boldone -2P_1)$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-114">Specifically, if $Q$ is the amplitude amplification iterate and $P_0$ is a projector operator onto the initial subspace and $P_1$ is the projector onto the marked subspace then $Q=-(\boldone-2P_0)(\boldone -2P_1)$.</span></span>  <span data-ttu-id="0bf0a-115">Recorde-se que um projetor é um operador hermitiano que tem valores eigenvalues $+1$ e $0$ e, como resultado, $(\boldone -2P_0)$ é unitário porque tem valores eigen que são raízes de unidade (neste caso $\pm $1$).</span><span class="sxs-lookup"><span data-stu-id="0bf0a-115">Recall that a projector is a Hermitian operator that has eigenvalues $+1$ and $0$ and as a result $(\boldone -2P_0)$ is unitary because it has eigenvalues that are roots of unity (in this case $\pm 1$).</span></span> <span data-ttu-id="0bf0a-116">Como exemplo, considere o caso da pesquisa de Grover com o estado inicial $H^{\otimes n} \ket{0}$ e estado marcado $\ket{m}$, $P_0 = H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}$ e $P_1= \ket{m}\bra{m}$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-116">As an example, consider the case of Grover's search with initial state $H^{\otimes n} \ket{0}$ and marked state $\ket{m}$, $P_0 = H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}$ and $P_1= \ket{m}\bra{m}$.</span></span>  <span data-ttu-id="0bf0a-117">Na maioria das aplicações de amplificação de amplitude $P_0$ será um projetor para um estado inicial, o que significa que $P_0 = \boldone -2\ket{\psi}\bra{\psi}$ para algum vetor $\ket{\psi}$; no entanto, para a amplicação de amplitude alheia $P_0$ irá normalmente projetar em muitos estados quânticos (isto é, a multiplicidade do valor eigenvalue de $+1$ de $P_0$ é superior a $1$).</span><span class="sxs-lookup"><span data-stu-id="0bf0a-117">In most applications of amplitude amplification $P_0$ will be a projector onto an initial state meaning that $P_0 = \boldone -2\ket{\psi}\bra{\psi}$ for some vector $\ket{\psi}$; however, for oblivious amplitude amplication $P_0$ will typically project onto many quantum states (i.e. the multiplicity of the $+1$ eigenvalue of $P_0$ is greater than $1$).</span></span>

<span data-ttu-id="0bf0a-118">A lógica por trás da amplificação amplitude segue diretamente da decomposição eigen de $Q$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-118">The logic behind amplitude amplification follows directly from the eigen-decomposition of $Q$.</span></span>  <span data-ttu-id="0bf0a-119">Especificamente, os eigenvectores de $Q$ que o estado inicial tem suporte não zero podem ser mostrados como combinações lineares dos eigenvectores de $+1$ de $P_0$ e $P_1$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-119">Specifically, the eigenvectors of $Q$ that the initial state has non-zero support over can be shown to be linear combinations of the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="0bf0a-120">Especificamente, o estado inicial de amplificação de amplitude (assumindo que é um eigenvector de $P_0$) pode ser escrito como $$ \ket{\psi}=\{-i}{{-i}{{{-i}{{{-i}{{sqrt{2}}\left (e^{i\theta}\ket{\psi_+} + e^{-i\\theta}\ket{\psi_-}\right), $$ket{\psi_\pm}$ são eigenvectores de $Q$ com valores eigen$e{^pm 2i\theta}$ e só têm suporte nos $+1$ eigenvectors de $P_0$ e $P_1$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-120">Specifically, the initial state for amplitude amplification (assuming it is a $+1$ eigenvector of $P_0$) can be written as $$ \ket{\psi}=\frac{-i}{\sqrt{2}}\left(e^{i\theta}\ket{\psi_+} + e^{-i\theta}\ket{\psi_-}\right), $$ where $\ket{\psi_\pm}$ are eigenvectors of $Q$ with eigenvalues $e^{\pm  2i\theta}$ and only have support on the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="0bf0a-121">O facto de os valores eigen are$e^{\pm i \theta}$ implica que o operador $Q$ realiza uma rotação num subespaço bidimensional especificado pelos dois projetores e o estado inicial em que o ângulo de rotação é $2\theta$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-121">The fact that the eigenvalues are $e^{\pm i \theta}$ implies that the operator $Q$ performs a rotation in a two-dimensional subspace specified by the two projectors and the initial state where the rotation angle is $2\theta$.</span></span>  <span data-ttu-id="0bf0a-122">É por isso que após $m as iterações de $Q$ a probabilidade de sucesso é $\sin^2([2m+1]\theta)$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-122">This is why after $m$ iterations of $Q$ the success probability is $\sin^2([2m+1]\theta)$.</span></span>

<span data-ttu-id="0bf0a-123">Outra propriedade útil que sai disto é que o eigenvalue $\theta$ está diretamente relacionado com a probabilidade de o estado inicial ser marcado (no caso em que $P_0$ é um projetor apenas para o estado inicial).</span><span class="sxs-lookup"><span data-stu-id="0bf0a-123">Another useful property that comes out of this is that the eigenvalue $\theta$ is directly related to probability that the initial state would be marked (in the case where $P_0$ is a projector onto only the initial state).</span></span>  <span data-ttu-id="0bf0a-124">Uma vez que as fases eigenphases de $Q$ são $2\teta = 2\sin{-1}(\sqrt{\Pr(sucesso)}}$ então segue-se que se aplicarmos estimativa de fase a $Q$ então podemos aprender a probabilidade de sucesso para um procedimento quântico unitário.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-124">Since the eigenphases of $Q$ are $2\theta = 2\sin^{-1}(\sqrt{\Pr(success)})$ it then follows that if we apply phase estimation to $Q$ then we can learn the probability of success for a unitary quantum procedure.</span></span>  <span data-ttu-id="0bf0a-125">Isto é útil porque requer quadraticamente menos aplicações do procedimento quântico para aprender a probabilidade de sucesso do que seria necessário de outra forma.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-125">This is useful because it requires quadratically fewer applications of the quantum procedure to learn the success probability than would otherwise be needed.</span></span>

<span data-ttu-id="0bf0a-126">Q# introduz a amplificação da amplitude como uma especialização da amplificação de amplitude alheia.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-126">Q# introduces amplitude amplification as a specialization of oblivious amplitude amplification.</span></span>  <span data-ttu-id="0bf0a-127">A amplificação de amplitude alheia ganha este apelido porque o projetor no espaço eigenspace inicial não precisa ser um projetor sobre o estado inicial.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-127">Oblivious amplitude amplification earns this moniker because the projector onto the initial eigenspace need not be a projector onto the initial state.</span></span>  <span data-ttu-id="0bf0a-128">Neste sentido, o protocolo é alheio ao estado inicial.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-128">In this sense, the protocol is oblivious to the initial state.</span></span>  <span data-ttu-id="0bf0a-129">A aplicação chave da amplificação de amplitude alheia está em certas *combinações lineares de* métodos de simulação unitária hamiltoniana, em que o estado inicial é desconhecido, mas fica enredado com um registo de acessórios no protocolo de simulação.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-129">The key application of oblivious amplitude amplification is in certain *linear combinations of unitary* Hamiltonian simulation methods, wherein the initial state is unknown but becomes entangled with an ancilla register in the simulation protocol.</span></span>  <span data-ttu-id="0bf0a-130">Se este registo acesso fosse medido como um valor fixo, digamos$0$, tais métodos de simulação aplicam a transformação unitária desejada aos restantes qubits (chamado registo do sistema).</span><span class="sxs-lookup"><span data-stu-id="0bf0a-130">If this ancilla register were to be measured to be a fixed value, say $0$, then such simulation methods apply the desired unitary transformation to the remaining qubits (called the system register).</span></span>  <span data-ttu-id="0bf0a-131">Todos os outros resultados de medição conduzem, no entanto, ao fracasso.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-131">All other measurement outcomes lead to failure however.</span></span>  <span data-ttu-id="0bf0a-132">A amplificação de amplitude alheia permite que a probabilidade de sucesso desta medição seja aumentada para $100\\%$ usando o raciocínio acima.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-132">Oblivious amplitude amplification allows the probability of success of this measurement to be boosted to $100\\%$ using the above reasoning.</span></span>  <span data-ttu-id="0bf0a-133">Além disso, a amplificação de amplitude comum corresponde ao caso em que o registo do sistema está vazio.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-133">Further, ordinary amplitude amplification corresponds to the case where the system register is empty.</span></span>  <span data-ttu-id="0bf0a-134">É por isso que Q# usa a amplificação de amplitude alheia como a sua subrotina de amplificação de amplitude fundamental.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-134">This is why Q# uses oblivious amplitude amplification as its fundamental amplitude amplification subroutine.</span></span>

<span data-ttu-id="0bf0a-135">A rotina geral (`AmpAmpObliviousByReflectionPhases`) tem dois registos a que chamamos `ancillaRegister` e `systemRegister`.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-135">The general routine (`AmpAmpObliviousByReflectionPhases`) has two registers that we call `ancillaRegister` and `systemRegister`.</span></span> <span data-ttu-id="0bf0a-136">Também aceita dois oráculos para as reflexões necessárias.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-136">It also accepts two oracles for the necessary reflections.</span></span> <span data-ttu-id="0bf0a-137">O `ReflectionOracle` atua apenas no `ancillaRegister` enquanto o `ObliviousOracle` atua conjuntamente em ambos os registos.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-137">The `ReflectionOracle` acts only on the `ancillaRegister` while the `ObliviousOracle` acts jointly on both registers.</span></span> <span data-ttu-id="0bf0a-138">A entrada para `ancillaRegister` deve ser inicializada para um -1 eigenstate do primeiro operador de reflexão $\boldone -2P_1$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-138">The input to `ancillaRegister` must be initialized to a -1 eigenstate of the first reflection operator $\boldone -2P_1$.</span></span>

<span data-ttu-id="0bf0a-139">Tipicamente, o oráculo prepara o estado na base computacional $\ket{0...0}$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-139">Typically, the oracle prepares the state in the computational basis $\ket{0...0}$.</span></span> <span data-ttu-id="0bf0a-140">Na nossa implementação, o `ancillaRegister` consiste de um qubit (`flagQubit`) que controla o `stateOracle` e o resto das auxiliares desejadas.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-140">In our implementation, the `ancillaRegister` consistes of one qubit (`flagQubit`) that controls the `stateOracle` and the rest of the desired ancillas.</span></span> <span data-ttu-id="0bf0a-141">O `stateOracle` é aplicado quando o `flagQubit` é $\ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-141">The `stateOracle` is applied when the `flagQubit` is $\ket{1}$.</span></span>

<span data-ttu-id="0bf0a-142">Também se pode fornecer oráculos `StateOracle` e `ObliviousOracle` em vez de reflexões através de um apelo à `AmpAmpObliviousByOraclePhases`.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-142">One may also provide oracles `StateOracle` and `ObliviousOracle` instead of reflections via a call to `AmpAmpObliviousByOraclePhases`.</span></span>

<span data-ttu-id="0bf0a-143">Como referido, a amplificação tradicional da Amplitude é apenas um caso especial destas rotinas em que `ObliviousOracle` é o operador de identidade e não existem qubits do sistema (isto é, `systemRegister` está vazio).</span><span class="sxs-lookup"><span data-stu-id="0bf0a-143">As mentioned, traditional Amplitude Amplification is just a special case of these routines where `ObliviousOracle` is the identity operator and there are no system qubits (i.e., `systemRegister` is empty).</span></span> <span data-ttu-id="0bf0a-144">Se desejar obter fases para reflexões parciais (por exemplo, para pesquisa de Grover), a função `AmpAmpPhasesStandard` está disponível.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-144">If you wish to obtain phases for partial reflections (e.g., for Grover search), the function `AmpAmpPhasesStandard` is available.</span></span> <span data-ttu-id="0bf0a-145">Por favor, consulte `DatabaseSearch.qs` para uma amostra de implementação do algoritmo de Grover.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-145">Please refer to `DatabaseSearch.qs` for a sample implementation of Grover's algorithm.</span></span>

<span data-ttu-id="0bf0a-146">Relacionamos as fases de rotação de um qubit às fases do operador de reflexão, tal como descrito no artigo pela [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span><span class="sxs-lookup"><span data-stu-id="0bf0a-146">We relate the single-qubit rotation phases to the reflection operator phases as described in the paper by [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span></span> <span data-ttu-id="0bf0a-147">As fases fixas de pontos que são usadas são detalhadas em [Yoder, Low e Chuang](https://arxiv.org/abs/1409.3305) juntamente com as fases em [Low, Yoder e Chuang.](https://arxiv.org/abs/1603.03996)</span><span class="sxs-lookup"><span data-stu-id="0bf0a-147">The fixed point phases that are used are detailed in [Yoder, Low and Chuang](https://arxiv.org/abs/1409.3305) along with the phases in [Low, Yoder and Chuang](https://arxiv.org/abs/1603.03996).</span></span>

<span data-ttu-id="0bf0a-148">Para segundo plano, pode começar a partir da [Amplificação Amplitude Padrão,](https://arxiv.org/abs/quant-ph/0005055) em seguida, passar para uma introdução à Amplificação amplitude [alheia](https://arxiv.org/abs/1312.1414) e, finalmente, generalizações apresentadas em [Low e Chuang](https://arxiv.org/abs/1610.06546).</span><span class="sxs-lookup"><span data-stu-id="0bf0a-148">For background, you could start from [Standard Amplitude Amplification](https://arxiv.org/abs/quant-ph/0005055) then move to an introduction to [Oblivious Amplitude Amplification](https://arxiv.org/abs/1312.1414) and finally generalizations presented in [Low and Chuang](https://arxiv.org/abs/1610.06546).</span></span> <span data-ttu-id="0bf0a-149">Uma bela apresentação geral de toda esta área (no que diz respeito à Simulação Hamiltonian) foi dada por [Dominic Berry.](http://www.dominicberry.org/presentations/Durban.pdf)</span><span class="sxs-lookup"><span data-stu-id="0bf0a-149">A nice overview presentation of this entire area (as it relates to Hamiltonian Simulation) was given by [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span></span>

## <a name="quantum-fourier-transform"></a><span data-ttu-id="0bf0a-150">Transformação quântica de fourier</span><span class="sxs-lookup"><span data-stu-id="0bf0a-150">Quantum Fourier Transform</span></span> ##

<span data-ttu-id="0bf0a-151">A transformação de Fourier é uma ferramenta fundamental da análise clássica e é igualmente importante para as computações quânticas.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-151">The Fourier transform is a fundamental tool of classical analysis and is just as important for quantum computations.</span></span>
<span data-ttu-id="0bf0a-152">Além disso, a eficiência da *transformação quântica fourier* (QFT) supera em muito o que é possível numa máquina clássica tornando-a uma das primeiras ferramentas de escolha ao conceber um algoritmo quântico.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-152">In addition, the efficiency of the *quantum Fourier transform* (QFT) far surpasses what is possible on a classical machine making it one of the first tools of choice when designing a quantum algorithm.</span></span>

<span data-ttu-id="0bf0a-153">Como uma generalização aproximada do QFT, fornecemos a operação <xref:microsoft.quantum.canon.approximateqft> que permite mais otimizações através da poda de rotações que não são estritamente necessárias para a precisão algorítmica desejada.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-153">As an approximate generalization of the QFT, we provide the <xref:microsoft.quantum.canon.approximateqft> operation that allows for further optimizations by pruning rotations that aren't strictly necessary for the desired algorithmic accuracy.</span></span>
<span data-ttu-id="0bf0a-154">O QFT aproximado requer a operação disadica $Z rotação de $<xref:microsoft.quantum.intrinsic.rfrac> bem como a operação <xref:microsoft.quantum.intrinsic.h>.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-154">The approximate QFT requires the dyadic $Z$-rotation operation <xref:microsoft.quantum.intrinsic.rfrac> as well as the <xref:microsoft.quantum.intrinsic.h> operation.</span></span>
<span data-ttu-id="0bf0a-155">Presume-se que a entrada e a saída estão codificadas na codificação de grandes endianos--- ou seja, o qubit com índice `0` é codificado na parte mais esquerda (mais alta) da representação binária do inteiro.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-155">The input and output are assumed to be encoded in big endian encoding---that is, the qubit with index `0` is encoded in the left-most (highest) bit of the binary integer representation.</span></span>
<span data-ttu-id="0bf0a-156">Isto alinha-se com a [notação](xref:microsoft.quantum.concepts.dirac)de ket , como um registo de três qubits no estado $\ket{100}$ corresponde a $q_0$ estando no estado $\ket{1}$ enquanto $q_1$ e $q_2$ estão ambos no estado $\ket{0}$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-156">This aligns with [ket notation](xref:microsoft.quantum.concepts.dirac), as a register of three qubits in the state $\ket{100}$ corresponds to $q_0$ being in the state $\ket{1}$ while $q_1$ and $q_2$ are both in state $\ket{0}$.</span></span>
<span data-ttu-id="0bf0a-157">O parâmetro de aproximação $a$ determina o nível de poda das rotações $Z$, ou seja, $a \in [0.n]$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-157">The approximation parameter $a$ determines the pruning level of the $Z$-rotations, i.e., $a \in [0..n]$.</span></span>
<span data-ttu-id="0bf0a-158">Neste caso, todos os $Z$-rotações $2\pi/2^k$ onde $k > a$ são removidos do circuito QFT.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-158">In this case all $Z$-rotations $2\pi/2^k$ where $k > a$ are removed from the QFT circuit.</span></span>
<span data-ttu-id="0bf0a-159">Sabe-se que por $k \ge \log_2(n) + \log_2(1 / \epsilon) + 3$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-159">It is known that for $k \ge \log_2(n) + \log_2(1 / \epsilon) + 3$.</span></span> <span data-ttu-id="0bf0a-160">pode-se vincular $\\[ ] \nome do operador{QFT} - \nome de operador{AQFT} \\\epsilon$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-160">one can bound $\\| \operatorname{QFT} - \operatorname{AQFT} \\| < \epsilon$.</span></span>
<span data-ttu-id="0bf0a-161">Aqui $\\\cdot\\[$] é a norma do operador que neste caso é a raiz quadrada do maior [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) de $(\operatorname{QFT} - \nome de operador{AQFT})(\nome de operador{QFT} - \nome de operador{AQFT}^\apunhala$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-161">Here $\\|\cdot\\|$ is the operator norm which in this case is the square root of the largest [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) of $(\operatorname{QFT} - \operatorname{AQFT})(\operatorname{QFT} - \operatorname{AQFT})^\dagger$.</span></span>

## <a name="arithmetic"></a><span data-ttu-id="0bf0a-162">Operações aritméticas</span><span class="sxs-lookup"><span data-stu-id="0bf0a-162">Arithmetic</span></span> ##

<span data-ttu-id="0bf0a-163">Tal como a aritmética desempenha um papel central na computação clássica, também é indispensável na computação quântica.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-163">Just as arithmetic plays a central role in classical computing, it is also indispensable in quantum computing.</span></span>  <span data-ttu-id="0bf0a-164">Algoritmos como o algoritmo de factoring de Shor, métodos de simulação quântica, bem como muitos algoritmos oraculares dependem de operações aritméticas coerentes.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-164">Algorithms such as Shor's factoring algorithm, quantum simulation methods as well as many oracular algorithms rely upon coherent arithmetic operations.</span></span>  <span data-ttu-id="0bf0a-165">A maioria das abordagens para a aritmética se baseia maquetes em circuitos quânticos adder.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-165">Most approaches to arithmetic build upon quantum adder circuits.</span></span>  <span data-ttu-id="0bf0a-166">O adder mais simples pega numa entrada clássica $b$ e adiciona o valor a um estado quântico segurando um integer $\ket{a}$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-166">The simplest adder takes a classical input $b$ and adds the value to a quantum state holding an integer $\ket{a}$.</span></span>  <span data-ttu-id="0bf0a-167">Matematicamente, o adder (que denotamos $\operatorname{Add}(b)$ para entrada clássica $b$) tem a propriedade que</span><span class="sxs-lookup"><span data-stu-id="0bf0a-167">Mathematically, the adder (which we denote $\operatorname{Add}(b)$ for classical input $b$) has the property that</span></span>

<span data-ttu-id="0bf0a-168">$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-168">$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.</span></span>
<span data-ttu-id="0bf0a-169">$$ Este circuito básico de adder é mais um incrementador do que um adder.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-169">$$ This basic adder circuit is more of an incrementer than an adder.</span></span>
<span data-ttu-id="0bf0a-170">Pode ser convertido num adder que tem duas inputs quânticas através de $$ \operatorname{Add}\ket{a}\ket{{{a}\ket{a+b}, $$ usando $n$ aplicações controladas de adders do formulário \start{align} \operatorname {Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left (\operatorname{Add}(1) \Lambda\_{a\_1} \left (\operatorname{Add}(2) \right) \Lambda\_{a\_2} \left (\operatorname{Add}(4) \cdots \Lambda\_{a\_{n-1}} \left nome de operador{Add}({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} para $n inteiros de bit de $bit $a$ e $b$ e adição de modulo $2^n$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-170">It can be converted into an adder that has two quantum inputs via $$ \operatorname{Add}\ket{a}\ket{b}=\ket{a}\ket{a+b}, $$ using $n$ controlled applications of adders of the form \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left(\operatorname{Add}(1) \right) \Lambda\_{a\_1} \left(\operatorname{Add}(2) \right) \Lambda\_{a\_2} \left(\operatorname{Add}(4) \right) \cdots \Lambda\_{a\_{n-1}} \left(\operatorname{Add}({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} for $n$-bit integers $a$ and $b$ and addition modulo $2^n$.</span></span>  <span data-ttu-id="0bf0a-171">Recorde-se que a notação $\Lambda\_x(A)$ refere-se, para qualquer operação $A$, à versão controlada dessa operação com o qubit $x$ como controlo.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-171">Recall that the notation $\Lambda\_x(A)$ refers, for any operation $A$, to the controlled version of that operation with the qubit $x$ as control.</span></span>

<span data-ttu-id="0bf0a-172">Da mesma forma, a multiplicação clássica controlada (uma forma modular da qual é essencial para o algoritmo de factoring de Shor) pode ser realizada utilizando uma série semelhante de adições controladas: \start{align} \operatorname{Mult}(a)\ket{x}\ket{b} & = \Lambda\_{x\_0}\left(\operatorname{Add}(2^0 a)\direita) \Lambda\_{a\_1}\left(\operatorname {Add}(2^1a)\direita) \Lambda\_{a\_2}\left (\operatorname{Add}(2^2 a)\à direita) \cdots \Lambda\_{x\_n-1}} \left (\operatorname{Add}({2^{n-1}a) \right)\ket{x}\ket{b} \\\\ & = \ket{x}\ket{b+ax}.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-172">Similarly, classically controlled multiplication (a modular form of which is essential for Shor's factoring algorithm) can be performed by using a similar series of controlled  additions: \begin{align} \operatorname{Mult}(a)\ket{x}\ket{b} & = \Lambda\_{x\_0}\left(\operatorname{Add}(2^0 a)\right) \Lambda\_{a\_1}\left(\operatorname{Add}(2^1a)\right) \Lambda\_{a\_2}\left(\operatorname{Add}(2^2 a)\right) \cdots \Lambda\_{x\_{n-1}} \left(\operatorname{Add}({2^{n-1}}a) \right)\ket{x}\ket{b} \\\\ & = \ket{x}\ket{b+ax}.</span></span>
<span data-ttu-id="0bf0a-173">\end{align} Existe uma subtileza com multiplicação nos computadores quânticos que pode notar a partir da definição de $\operatorname{Mult}$ acima.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-173">\end{align} There is a subtlety with multiplication on quantum computers that you may notice from the definition of $\operatorname{Mult}$ above.</span></span>  <span data-ttu-id="0bf0a-174">Ao contrário da adição, a versão quântica deste circuito armazena o produto das inputs num registo acessório e não no registo de entrada.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-174">Unlike addition, the quantum version of this circuit stores the product of the inputs in an ancillary register rather than in the input register.</span></span>  <span data-ttu-id="0bf0a-175">Neste exemplo, o registo é inicializado com o valor $b$, mas normalmente começará a deter o valor zero.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-175">In this example, the register is initialized with the value $b$, but typically it will start holding the value zero.</span></span>  <span data-ttu-id="0bf0a-176">Isto é necessário porque, em geral, não há um inverso multiplicador para $a gerais e $x$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-176">This is needed in because in general there is not a multiplicative inverse for general $a$ and $x$.</span></span>  <span data-ttu-id="0bf0a-177">Uma vez que todas as operações quânticas, exceto a medição, são reversíveis, precisamos de manter informação suficiente para inverter a multiplicação.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-177">Since all quantum operations, save measurement, are reversible we need to keep enough information around to invert the multiplication.</span></span>  <span data-ttu-id="0bf0a-178">Por esta razão, o resultado é armazenado numa matriz separada.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-178">For this reason the result is stored in a separate array.</span></span>  <span data-ttu-id="0bf0a-179">Este truque de salvar a saída de uma operação irreversível, como a multiplicação, num registo separado é conhecido como o "truque Bennett" depois de Charlie Bennett e é uma ferramenta fundamental na computação reversível e quântica.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-179">This trick of saving the output of an irreversible operation, like multiplication, in a separate register is known as the "Bennett trick" after Charlie Bennett and is a fundamental tool in both reversible and quantum computing.</span></span>

<span data-ttu-id="0bf0a-180">Muitos circuitos quânticos foram propostos para adição e cada um explora uma compensação diferente em termos do número de qubits (espaço) e do número de operações do portão (tempo) necessários.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-180">Many quantum circuits have been proposed for addition and each explores a different tradeoff in terms of the number of qubits (space) and the number of gate operations (time) required.</span></span>  <span data-ttu-id="0bf0a-181">Revemos dois adders altamente eficientes em termos de espaço abaixo conhecidos como o adder Draper e o adder Beauregard.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-181">We review two highly space efficient adders below known as the Draper adder and the Beauregard adder.</span></span>

### <a name="draper-adder"></a><span data-ttu-id="0bf0a-182">Draper Adder</span><span class="sxs-lookup"><span data-stu-id="0bf0a-182">Draper Adder</span></span> ###

<span data-ttu-id="0bf0a-183">O adder Draper é indiscutivelmente um dos mais elegantes adders quânticos, uma vez que invoca diretamente propriedades quânticas para realizar a adição.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-183">The Draper adder is arguably one of the most elegant quantum adders, as it directly invokes quantum properties to perform addition.</span></span>  <span data-ttu-id="0bf0a-184">A perceção por trás do adder Draper é que a transformação de Fourier pode ser usada para traduzir mudanças de fase em uma pequena mudança.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-184">The insight behind the Draper adder is that the Fourier transform can be used to translate phase shifts into a bit shift.</span></span>  <span data-ttu-id="0bf0a-185">Segue-se que aplicando uma transformação fourier, aplicando turnos de fase apropriados, e, em seguida, desfazer a transformação fourier você pode implementar um adder.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-185">It then follows that by applying a Fourier transform, applying appropriate phase shifts, and then undoing the Fourier transform you can implement an adder.</span></span>  <span data-ttu-id="0bf0a-186">Ao contrário de muitos outros adders que foram propostos, o adder Draper usa explicitamente os efeitos quânticos introduzidos através da transformação quântica fourier.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-186">Unlike many other adders that have been proposed, the Draper adder explicitly uses quantum effects introduced through the quantum Fourier transform.</span></span>  <span data-ttu-id="0bf0a-187">Não tem uma contrapartida clássica natural.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-187">It does not have a natural classical counterpart.</span></span>  <span data-ttu-id="0bf0a-188">Os passos específicos do adder Draper são dados abaixo.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-188">The specific steps of the Draper adder are given below.</span></span>

<span data-ttu-id="0bf0a-189">Assuma que tem dois registos de qubit de $n$bits armazenando os inteiros $a$ e $b$ então para todos os $a$ $$ \operatorname{QFT}\ket{a}= \frac{1}{\sqrt{2^n}}}}\sum\_{j=0}^{2^n-1} e^{i2\pi(aj)/2^n} \ket{j}.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-189">Assume that you have two $n$-bit qubit registers storing the integers $a$ and $b$ then for all $a$ $$ \operatorname{QFT}\ket{a}= \frac{1}{\sqrt{2^n}}\sum\_{j=0}^{2^n-1} e^{i2\pi(aj)/2^n} \ket{j}.</span></span>
<span data-ttu-id="0bf0a-190">$$ Se definirmos $$ \ket {\phi\_k(a)} = \frac{1}{\sqrt{2}}\left (\ket{0} + e^{i2\pi a /2^k}\ket{1} \right), $$ e depois alguma álgebra pode ver que $$ \operatorname{QFT}\ket{a}=\ket{\phi\_1(a)}\otimes \cdots \otimes \ket{\phi\_(a)}.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-190">$$ If we define $$ \ket{\phi\_k(a)} = \frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi a /2^k}\ket{1} \right), $$ then after some algebra you can see that $$ \operatorname{QFT}\ket{a}=\ket{\phi\_1(a)}\otimes \cdots \otimes \ket{\phi\_n(a)}.</span></span>
<span data-ttu-id="0bf0a-191">$$ O caminho para a realização de um adder torna-se claro depois de observar que a soma das inputs pode ser escrita como $$ \ket{a+b}=\operatorname{QFT}^{-1}\ket{\phi\_1(a+b)}\otimes \cdots \otimes \ket{\phi\_n (a+b)}.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-191">$$ The path towards performing an adder then becomes clear after observing that the sum of the inputs can be written as $$ \ket{a+b}=\operatorname{QFT}^{-1}\ket{\phi\_1(a+b)}\otimes \cdots \otimes \ket{\phi\_n(a+b)}.</span></span>
<span data-ttu-id="0bf0a-192">$$ Os inteiros $b$ e $a$ podem então ser adicionados através da realização de rotação de fase controlada em cada um dos qubits na decomposição usando os pedaços de $b$ como controlos.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-192">$$ The integers $b$ and $a$ can then be added by performing controlled-phase rotation on each of the qubits in the decomposition using the bits of $b$ as controls.</span></span>

<span data-ttu-id="0bf0a-193">Esta expansão pode ser simplificada notando que para qualquer $j de sempre e número real $x$, $e^{i2\pi(x+j)}=e^{i2\pi x}$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-193">This expansion can be further simplified by noting that for any integer $j$ and real number $x$, $e^{i2\pi(x+j)}=e^{i2\pi x}$.</span></span>  <span data-ttu-id="0bf0a-194">Isto porque se rodar $360^{\circ}$ graus ($2\pi$$ radians) em círculo, então você acaba precisamente onde você começou.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-194">This is because if you rotate $360^{\circ}$ degrees ($2\pi$ radians) in a circle then you end up precisely where you started.</span></span>  <span data-ttu-id="0bf0a-195">A única parte importante de $x$ para $e^{i2\pi x}$ é, portanto, a parte fracionária de $x$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-195">The only important part of $x$ for $e^{i2\pi x}$ is therefore the fractional part of $x$.</span></span>  <span data-ttu-id="0bf0a-196">Especificamente, se tivermos uma expansão binária da forma $x=y+0,x\_0x\_2\ldots x\_n$ e depois $e^{i2\pi x}=e^{i2\pi (0,x\_0x\_2\ldots x\_{n-1}}}}}}$e, portanto, $\ket{{i2\pi=e^{i2\pi (0,x  0x  2\ldots x  {n-1}}}}}}$e, portanto, $$\ket\_{{i2\pi=e^{i2\pi (0,x  0x  2\ldots x  {n-1})}}}$e, portanto, $\ket{{i2\pi=e^{i2\pi (0,x  0x  2\ldots x  {n-1}}}}}}}}}}}}}}}}}\frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi [a/2^k+0.b\_k\ldots b\_1]}\ket{1} \right).$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ o número de rotações diminui à medida que $k$ diminui.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-196">Specifically, if we have a binary expansion of the form $x=y+0.x\_0x\_2\ldots x\_n$ then $e^{i2\pi x}=e^{i2\pi (0.x\_0x\_2\ldots x\_{n-1})}$ and hence $$\ket{\phi\_k(a+b)}=\frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi [a/2^k+0.b\_k\ldots b\_1]}\ket{1} \right).$$ This means that if we perform addition by incrementing each of the tensor factors in the expansion of the Fourier transform of $\ket{a}$ then the number of rotations shrinks as $k$ decreases.</span></span>  <span data-ttu-id="0bf0a-197">Isto reduz substancialmente o número de portões quânticos necessários no adder.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-197">This substantially reduces the number of quantum gates needed in the adder.</span></span>  <span data-ttu-id="0bf0a-198">Denotamos a transformação fourier, a adição de fase e os passos de transformação inversa fourier que compõem o adder Draper como $\operatorname{QFT}^{-1} à esquerda (\phi\\\!\operatorname{ADD}\right) \nome de operador{QFT}$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-198">We denote the Fourier transform, phase addition and the inverse Fourier transform steps that comprise the Draper adder as $\operatorname{QFT}^{-1} \left(\phi\\\!\operatorname{ADD}\right) \operatorname{QFT}$.</span></span> <span data-ttu-id="0bf0a-199">Um circuito quântico que usa esta simplificação para implementar todo o processo pode ser visto abaixo.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-199">A quantum circuit that uses this simplification to implement the entire process can be seen below.</span></span>

![Adder draper mostrado como diagrama de circuito](~/media/draper.svg)

<span data-ttu-id="0bf0a-201">Cada portão controlado $e^{i2\pi/k}$ no circuito refere-se a um portão de fase controlada.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-201">Each controlled $e^{i2\pi/k}$ gate in the circuit refers to a controlled-phase gate.</span></span>  <span data-ttu-id="0bf0a-202">Tais portões têm a propriedade que no par de qubits em que atuam, $\ket{00}\mapsto \ket{00}$ mas $\ket{11}\mapsto e^{i2\pi/k}\ket{11}$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-202">Such gates have the property that on the pair of qubits on which they act, $\ket{00}\mapsto \ket{00}$ but $\ket{11}\mapsto e^{i2\pi/k}\ket{11}$.</span></span>  <span data-ttu-id="0bf0a-203">Este circuito permite-nos realizar a adição sem qubits adicionais para além dos necessários para armazenar as inputs e as saídas.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-203">This circuit allows us to perform addition using no additional qubits apart from those needed to store the inputs and the outputs.</span></span>

### <a name="beauregard-adder"></a><span data-ttu-id="0bf0a-204">Beauregard Adder</span><span class="sxs-lookup"><span data-stu-id="0bf0a-204">Beauregard Adder</span></span> ###

<span data-ttu-id="0bf0a-205">O adder Beauregard é um adder modular quântico que usa o adder Draper para executar adição de modulo $N$ para um valor arbitrário positivo inteiro $N$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-205">The Beauregard adder is a quantum modular adder that uses the Draper adder in order to perform addition modulo $N$ for an arbitrary value positive integer $N$.</span></span>  <span data-ttu-id="0bf0a-206">A importância dos adders modulares quânticos, como o adder Beauregard, decorre em grande parte da sua utilização no passo de exponenciação modular dentro do algoritmo de Shor para factoring.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-206">The significance of quantum modular adders, such as the Beauregard adder, stems to a large extent from their use in the modular exponentiation step within Shor's algorithm for factoring.</span></span>  <span data-ttu-id="0bf0a-207">Um adder modular quântico tem a seguinte ação para entrada quântica $\ket{b}$ e entrada clássica $a$ onde $a$ e $b$ são prometidos para serem inteiros mod $N$, o que significa que eles estão no intervalo $[0,\ldots, N-1]$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-207">A quantum modular adder has the following action for quantum input $\ket{b}$ and classical input $a$ where $a$ and $b$ are promised to be integers mod $N$, meaning that they are in the interval $[0,\ldots, N-1]$.</span></span>

<span data-ttu-id="0bf0a-208">$$ \ket{b}\rightarrow \ket{b+a \text { mod }N}=\begin{cases} \ket{b+a},& b+a < N\\\\ \ket{b+a-N},& (b+a)\ge N \end{cases}.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-208">$$ \ket{b}\rightarrow \ket{b+a \text{ mod }N}=\begin{cases} \ket{b+a},& b+a < N\\\\ \ket{b+a-N},& (b+a)\ge N \end{cases}.</span></span>
$$

<span data-ttu-id="0bf0a-209">O adder Beauregard usa o adder Draper, ou mais especificamente $\phi\\\!nome de operador {ADD}$, para adicionar $a$ e $b$ em fase.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-209">The Beauregard adder uses the Draper adder, or more specifically $\phi\\\!\operatorname{ADD}$, to add $a$ and $b$ in phase.</span></span>  <span data-ttu-id="0bf0a-210">Em seguida, utiliza a mesma operação para identificar se $a+b <N$ subtraindo $N$ e testando se $a+b-N<0$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-210">It then uses the same operation to identify whether $a+b <N$ by subtracting $N$ and testing if $a+b-N<0$.</span></span>  <span data-ttu-id="0bf0a-211">O circuito armazena esta informação num qubit acessório e adiciona $N$ de volta ao registo se $a+b<N$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-211">The circuit stores this information in an ancillary qubit and then adds $N$ back the register if $a+b<N$.</span></span>  <span data-ttu-id="0bf0a-212">Conclui então, descomputando esta broca acessória (este passo é necessário para garantir que a cilla pode ser desalocado após chamar o adder).</span><span class="sxs-lookup"><span data-stu-id="0bf0a-212">It then concludes by uncomputing this ancillary bit (this step is needed to ensure that the ancilla can be de-allocated after calling the adder).</span></span>  <span data-ttu-id="0bf0a-213">O circuito para o adder Beauregard é dado abaixo.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-213">The circuit for the Beauregard adder is given below.</span></span>

![Beauregard adder mostrado como diagrama de circuito](~/media/beau.svg)

<span data-ttu-id="0bf0a-215">Aqui o portão $\Phi\\\!nome de operador{ADD}$ assume o mesmo formulário que $\phi\\\!nome de operador {ADD}$ exceto que neste contexto a entrada é clássica e não quântica.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-215">Here the gate $\Phi\\\!\operatorname{ADD}$ takes the same form as $\phi\\\!\operatorname{ADD}$ except that in this context the input is classical rather than quantum.</span></span>  <span data-ttu-id="0bf0a-216">Isto permite que as fases controladas em $\Phi\\\!o nome de operador {ADD}$ seja substituído por portões de fase que podem ser compilados em menos operações para reduzir tanto o número de qubits como o número de portões necessários para o adder.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-216">This allows the controlled phases in $\Phi\\\!\operatorname{ADD}$ to be replaced with phase gates that can then be compiled together into fewer operations to reduce both the number of qubits and number of gates needed for the adder.</span></span>

<span data-ttu-id="0bf0a-217">Para mais detalhes, consulte [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) e [D. Coppersmith.](https://arxiv.org/abs/quant-ph/0201067)</span><span class="sxs-lookup"><span data-stu-id="0bf0a-217">For more details, please refer to [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) and [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span></span>

### <a name="quantum-phase-estimation"></a><span data-ttu-id="0bf0a-218">Estimativa da Fase Quântica</span><span class="sxs-lookup"><span data-stu-id="0bf0a-218">Quantum Phase Estimation</span></span> ###

<span data-ttu-id="0bf0a-219">Uma aplicação particularmente importante da transformação quântica fourier é aprender os valores eigen dos operadores unitários, um problema conhecido como estimativa de *fase.*</span><span class="sxs-lookup"><span data-stu-id="0bf0a-219">One particularly important application of the quantum Fourier transform is to learn the eigenvalues of unitary operators, a problem known as *phase estimation*.</span></span>
<span data-ttu-id="0bf0a-220">Considere um $U unitário$ e um estado $\ket{\phi}$ tal que $\ket{\phi}$ é um estado eigene de $U$ com eigenvalue $\phi$, \start{equação} U\ket{\phi} = \phi\ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-220">Consider a unitary $U$ and a state $\ket{\phi}$ such that $\ket{\phi}$ is an eigenstate of $U$ with unknown eigenvalue $\phi$, \begin{equation} U\ket{\phi} = \phi\ket{\phi}.</span></span>
<span data-ttu-id="0bf0a-221">\end{equation} Se tivermos apenas acesso a $U$ como um oráculo, então podemos aprender a fase $\phi$ utilizando que as rotações de $Z$ aplicadas ao alvo de uma operação controlada propagam-se de volta ao controlo.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-221">\end{equation} If we only have access to $U$ as an oracle, then we can learn the phase $\phi$ by utilizing that $Z$ rotations applied to the target of a controlled operation propagate back onto the control.</span></span>

<span data-ttu-id="0bf0a-222">Suponha que $V$ é uma aplicação controlada de $U$, de tal forma que \start{align} V (\ket{0} \otimes \ket{\phi}) & = \ket{0} \otimes \ket {\phi} \\\\ \textrm{ e } V (\ket{1} \otimes \ket {\phi}) & e{{i \phi} \ket{1} \otimes \ket {{}}</span><span class="sxs-lookup"><span data-stu-id="0bf0a-222">Suppose that $V$ is a controlled application of $U$, such that \begin{align} V (\ket{0} \otimes \ket{\phi}) & =            \ket{0} \otimes \ket{\phi} \\\\ \textrm{ and } V (\ket{1} \otimes \ket{\phi}) & = e^{i \phi} \ket{1} \otimes \ket{\phi}.</span></span>
<span data-ttu-id="0bf0a-223">\end{align} Então, por linearidade, \start{align} V (\ket{+} \otimes \ket{\phi}) & = \frac{ (\ket{0} \otimes \ket{\phi}) + e^{i \phi} (\ket{1} \otimes \ket {\phi}) }{{sqrt{2}}.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-223">\end{align} Then, by linearity, \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{ (\ket{0} \otimes \ket{\phi}) + e^{i \phi} (\ket{1} \otimes \ket{\phi}) }{\sqrt{2}}.</span></span>
<span data-ttu-id="0bf0a-224">\end{align} Podemos recolher termos para descobrir que \start{align} V (\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e^{i \phi} \ket{1}}{\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1(\phi) \ket{+}) \otimes \ket{\phi}, \end{{} where $R_1$ é o unitário aplicado pelo funcionamento <xref:microsoft.quantum.intrinsic.r1>.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-224">\end{align} We can collect terms to find that \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e^{i \phi} \ket{1}}{\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1(\phi) \ket{+}) \otimes \ket{\phi}, \end{align} where $R_1$ is the unitary applied by the <xref:microsoft.quantum.intrinsic.r1> operation.</span></span>
<span data-ttu-id="0bf0a-225">Dito de outra forma, o efeito de aplicar $V$ é precisamente o mesmo que aplicar $R_1$ com um ângulo desconhecido, mesmo que só tenhamos acesso a $V$ como um oráculo.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-225">Put differently, the effect of applying $V$ is precisely the same as applying $R_1$ with an unknown angle, even though we only have access to $V$ as an oracle.</span></span>
<span data-ttu-id="0bf0a-226">Assim, para o resto desta discussão discutiremos a estimativa de fase em termos de $R_1(\phi)$, que implementamos utilizando o chamado recuo de *fase*.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-226">Thus, for the rest of this discussion we will discuss phase estimation in terms of $R_1(\phi)$, which we implement by using so-called *phase kickback*.</span></span>

<span data-ttu-id="0bf0a-227">Uma vez que o registo de controlo e alvo permanece desemaranhado após este processo, podemos reutilizar $\ket{\phi}$ como alvo de uma aplicação controlada de $U^2$ para preparar um segundo qubit de controlo no estado $R_1(2 \phi) \ket{+}$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-227">Since the control and target register remain untangled after this process, we can reuse $\ket{\phi}$ as the target of a controlled application of $U^2$ to prepare a second control qubit in the state $R_1(2 \phi) \ket{+}$.</span></span>
<span data-ttu-id="0bf0a-228">Continuando desta forma, podemos obter um registo do formulário \begin{align} \ket{\psi} & = \sum_{j = 0}^n R_1(2^j \phi) \ket{{}} \\\\ & \propto \bigotimes_{j=0}^{n} \left (\ket{0} + \exp(i^{j} \phi) \ket{1}\right \\ \\\propto \sum_{k = 0}^{2^n - 1} \exp(i \phi k) \ket{k} \end{align} onde $n$ é o número de pedaços de precisão que exigimos, e onde usamos ${} €propto {}$ para indicar que suprimimos o fator de normalização de $1 / \sqrt {2^n}$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-228">Continuing in this way, we can obtain a register of the form \begin{align} \ket{\psi} & = \sum_{j = 0}^n R_1(2^j \phi) \ket{+} \\\\ & \propto \bigotimes_{j=0}^{n} \left(\ket{0} + \exp(i 2^{j} \phi) \ket{1}\right) \\\\ & \propto \sum_{k = 0}^{2^n - 1} \exp(i \phi k) \ket{k} \end{align} where $n$ is the number of bits of precision that we require, and where we have used ${} \propto {}$ to indicate that we have suppressed the normalization factor of $1 / \sqrt{2^n}$.</span></span>

<span data-ttu-id="0bf0a-229">Se assumirmos que $\phi = 2 \pi p / 2^k$ para um inteiro $p$, então reconhecemos isto como $\ket{\psi} = \operatorname{QFT} \ket{p_1 p_0 \dots p_n}$, onde $p_j$ é o $j^{\textrm{th}}$$ bit de $2 \pi \phi$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-229">If we assume that $\phi = 2 \pi p / 2^k$ for an integer $p$, then we recognize this as $\ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n}$, where $p_j$ is the $j^{\textrm{th}}$ bit of $2 \pi \phi$.</span></span>
<span data-ttu-id="0bf0a-230">Aplicando a adjoint da transformação quântica fourier, obtemos assim a representação binária da fase codificada como um estado quântico.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-230">Applying the adjoint of the quantum Fourier transform, we therefore obtain the binary representation of the phase encoded as a quantum state.</span></span>

<span data-ttu-id="0bf0a-231">Em Q#, esta é implementada pela operação <xref:microsoft.quantum.characterization.quantumphaseestimation>, que leva uma aplicação <xref:microsoft.quantum.oracles.discreteoracle> implementação de $U^m$ em função de inteiros positivos $m$.</span><span class="sxs-lookup"><span data-stu-id="0bf0a-231">In Q#, this is implemented by the <xref:microsoft.quantum.characterization.quantumphaseestimation> operation, which takes a <xref:microsoft.quantum.oracles.discreteoracle> implementing application of $U^m$ as a function of positive integers $m$.</span></span>
