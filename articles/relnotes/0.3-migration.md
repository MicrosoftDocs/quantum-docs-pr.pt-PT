---
title: QDK 0.3 Guia de Revisão de Línguas e Migração
description: Descreve as novas funcionalidades no Microsoft Quantum Development Kit 0.3 e como migrar os programas Q# existentes.
author: beheim
uid: microsoft.quantum.relnotes.migration-0-3
ms.author: bettina.heim@microsoft.com
ms.date: 10/29/2018
ms.topic: article
ms.openlocfilehash: df86bf163a300c1ce55d3959bd40aea3d8b8a973
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: pt-PT
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907737"
---
# <a name="qdk-03-language-release-notes-and-migration-guide"></a>Notas de lançamento de línguas QDK 0.3 e guia de migração

Estamos entusiasmados por apresentar a mais recente atualização ao Kit de Desenvolvimento Quântico.  Esta página dá uma visão geral das novas funcionalidades da linguagem Q# e descreve como [migrar](#Migration) os programas Q# existentes para a nova sintaxe.  Consulte a nossa documentação completa para a descrição completa da língua Q# [aqui](xref:microsoft.quantum.language.intro).


## <a name="whats-new"></a>Novidades 

A atualização 0.3 vem com uma gama de novas funcionalidades de linguagem e editor.

### <a name="overview-of-features"></a>Visão geral das características

- Maior integração de ferramentas de desenvolvimento para Visual Studio e Visual Studio Code, incluindo:
    - Compilação ao vivo e feedback sobre dactilografia *(também conhecido como* sublinhando squiggly).
    - Informações sobre o hover, incluindo resumos de documentação e assinaturas de tipo.
    - Suporte para ir à definição.
    - Fácil navegação para nomear declarações de espaço, operação, função e tipo.
    - Mensagens de diagnóstico melhoradas.
- Melhorias linguísticas
    - Iniciais simples de qubit e tuple dentro da utilização e do empréstimo
    - Desconstrução de Tuple em todas as atribuições
    - Iteração sobre matrizes
    - Expressões condicionais
    - Abreviatura de especialização por defeito para operações
    - Construtores de tipo gerados automaticamente
    - Modificadores de expressão


## <a name="editor-features"></a>Características do editor

O Quantum Development Kit inclui agora um servidor de idiomas para Q#, bem como as integrações de clientes para Visual Studio e Visual Studio Code.
Tal permite um novo conjunto de funcionalidades do IntelliSense, juntamente com os comentários em direto sobre a escrita de sublinhados ondulados de erros e avisos.
Em particular, a definição é agora suportada e as informações sobre pairar são apresentadas contendo informações de tipo, bem como informações de documentar comentários. Além disso, informações de símbolos sobre espaços de nomedefinidos, operações, funções e tipos estão disponíveis e permitem navegar rapidamente para declarações.    
Esta atualização melhora bastante as mensagens de diagnóstico em geral, com navegação fácil e intervalos precisos para diagnóstico e detalhes adicionais nas informações apresentadas durante a passagem do rato. 

Para este lançamento 0.3, o servidor de idiomas incluído no Kit de Desenvolvimento Quântico não suporta vários espaços de trabalho.
Para trabalhar com um projeto em Código VS, abra a pasta raiz contendo o próprio projeto e todos os projetos referenciados.
Para poder trabalhar com uma solução no Visual Studio, todos os projetos contidos na solução têm de estar na mesma pasta que a solução ou numa das suas subpastas.

## <a name="language-features"></a>Características linguísticas

Em termos de características linguísticas, esta atualização unifica o tratamento de uma série de padrões linguísticos.
Os construtores de tipos, como exemplo, são gerados para cada tipo definido pelo utilizador e podem ser parcialmente aplicados como qualquer outra função.
Outro exemplo é a desconstrução de tuple, que agora é totalmente apoiada em todas as atribuições. Isto inclui não só let-, mutable e set-statements, mas também a variável iteração em for-loops, bem como a atribuição de utilização e empréstimos. Adicionalmente, as desconstruções parciais são recentemente suportadas com a atualização 0.3; sublinhações em desconstruções indicam partes do valor que devem ser ignorados. 

O seguinte código ilustra algumas das novas funcionalidades:
```qsharp
    let tuples = [(1, 0), (0, 1)];
    mutable res = (0, 0, 0);

    // For-loops can iterate over arrays, and can destructure tuples.
    for ((i1, i2) in tuples) {

        // Mutable assignments can now destructure and ignore parts of tuples,
        // using the same syntax as let-bindings.
        mutable (r1, r2, _) = res;
        set (r1, r2) = (r1 ||| i1, r2 &&& i2);

        let (_, _, s) = res;
        // The new conditional operator can be used inside expressions, avoiding
        // the need for extraneous if-statements.
        set res = (r1, r2, r1 == r2 ? s | s + 1);
    }
```
A última declaração do conjunto utiliza um novo operador ternário que é introduzido com a atualização 0.3 para suportar expressões condicionais.
Uma expressão condicional é uma expressão da forma `condition ? caseTrue | caseFalse`.
Como se pode ver pelo exemplo acima, a iteração sobre as matrizes é agora também apoiada.

As dotações no âmbito `using` e `borrowing` são recentemente possíveis para qubits individuais, matrizes de qubit e tuples aninhados dos mesmos:
```qsharp
    using (qubit = Qubit()) {
        // qubit contains a single qubit
    }

    borrowing ((qubits, qubit) = (Qubit[3], Qubit())) {
        // qubits contains an array of three qubits, and qubit contains a single qubit
    }
```

São introduzidas duas novas diretivas geradoras de especialização `invert` e `distribute`, para além de `auto`, para aumentar o controlo sobre a forma como as especializações de functores são geradas.
Uma declaração explícita do padrão `body` especialização dentro das operações já não é obrigatória.
Semelhante supor funções, as declarações podem ser diretamente adicionadas à própria declaração de operação se não for em funcionamento qualquer outra especialização.
Um script de migração está incluído no lançamento para ajudar a migrar o código existente e tirar partido de novas funcionalidades linguísticas (ver a [secção sobre o script de migração).](#MigrationScript)

Uma grande mudança na forma como os tipos definidos pelo utilizador são tratados vem com a atualização 0.3. Embora as libertações prévias do utilizador tenham definido os tipos como subtipos do seu tipo subjacente, este já não é o caso a seguir em frente (ver também a [secção sobre alterações](#BreakingChanges)de rutura).  
Como parte desta mudança introduzimos modificadores de expressão que podem ser aplicados a certas expressões. As expressões "atómicas" a que os modificadores podem ser aplicados são identificadores, expressões de item de matriz e tuples arity-1.
Os modificadores ligam-se mais apertado do que qualquer outro combinador de expressão e, em particular, mais apertado do que o combinador de expressão de chamada `(` `)`. 
`Adjoint`, `Controlled`, e um novo operador de pósfixo "desembrulhar" `!` são tratados como modificadores de expressão. Tratar `Adjoint` e `Controlled` como modificadores de expressão elimina a necessidade de parênteses para muitos casos. As expressões abaixo, por exemplo, são válidas para `Op`, uma operação unitária, `opArr` um conjunto de operações unitárias, e `arg` um argumento adequado: 
```qsharp
    Adjoint Op (arg);
    Controlled opArr[i] (arg);
```
O roteiro de migração vai deixar cair a maior parte dos parênteses desnecessários e tirar o máximo partido das novas funcionalidades. No entanto, esteja avisado de que o script não interpreta o código, e não terá em conta a interpretação diferente do functor `Controlled` em casos raros (apenas relevante em combinação com aplicações parciais).

O novo modificador `!` lança um tipo definido pelo utilizador para o seu tipo subjacente. Este elenco foi considerado um upcast em lançamentos anteriores e foi executado automaticamente. Com a nova interpretação dos tipos definidos pelo utilizador, este já não é o caso e o elenco tem de ser explicitado.    
O exemplo que se segue ilustra como utilizar o novo modificador: 
```qsharp
    newtype Unitary = (Qubit => Unit: Adjoint, Controlled);

    operation Foo (unitaries : Unitary[], qubit : Qubit) : Unit {

        for (unitary in unitaries[1 .. Length(unitaries)-1]) {
            // Each element of unitaries is an instance of the user-defined
            // type Unitary, so unitary! unwraps each element to an operation
            // type that we can call.
            unitary! (qubit);
            // The unwrap operator can also be used as a part of functor
            // expressions and when indexing into arrays.
            Adjoint unitary! (qubit);
            Adjoint unitaries[0]! (qubit);
        }
    }
```
Como se pode ver pelo exemplo, `!` se liga mais apertado do que os modificadores prefixos, como `Controlled` e `Adjoint`.

## <a name="BreakingChanges"></a>Alterações de rutura 

A atualização 0.3 vem com um novo compilador e contém um punhado de mudanças de rutura.
Para facilitar a atualização do código existente, o compilador também fornece uma opção de formatação que compila código válido ou inválido e emite código Q# formado com base na compilação construída.
Todas as alterações de sintaxe serão processadas automaticamente pela ferramenta fornecida. No entanto, as alterações na forma como o código válido é interpretado (alterações semânticas) podem ter de ser feitas manualmente. 

Além das alterações listadas abaixo, o padrão `__*__` onde * é qualquer sequência de caracteres não-espaciais é reservado para uso interno e não pode ser usado como um nome de símbolo.  

## <a name="syntax-changes"></a>Alterações de Sintaxe 

- A partir da versão 0.3, os itens de matriz já não são separados por pontos evímetros, mas são separados por vírgulas.
- Por outro lado, é necessário um ponto evícito após uma diretiva relativa à produção automática de declarações de especialização.
- As condições em se-, elif-, e até que as cláusulas devem ser encapsuladas em parênteses. 

Para todas as outras alterações de sintaxe, o compilador irá simplesmente gerar um aviso se a antiga sintaxe for utilizada.     
Um exemplo para tal mudança é o símbolo tuple em especializações definidas pelo utilizador. Embora em lançamentos anteriores uma declaração de especialização comperejá-a djoint controlada ou controlada especificasse um único argumento de símbolo, a partir de 0.3 é encorajado a fornecer tal túnica de símbolo para toda a especialização com `...` indicando que o compilador deve migrar os símbolos da declaração calúgica, se necessário. 

## <a name="semantic-changes"></a>Alterações Semânticas 

A rutura mais impactante para a versão 0.3 é a forma como os tipos definidos pelo utilizador são integrados no sistema de tipo. Em lançamentos anteriores, os tipos definidos pelo utilizador foram considerados um subtipo do seu tipo subjacente. Com esta libertação e a avançar, este já não é o caso. Os tipos definidos pelo utilizador são agora considerados como o seu próprio tipo distinto, e não existe um elenco automático entre um tipo definido pelo utilizador e o seu tipo subjacente. Todos os moldes devem ser explicitados através de um operador "desembrulhar" `!`, e é necessário um molde em particular para aceder ao conteúdo de um objeto de tipo definido pelo utilizador.  

As modificações no sistema de tipo também incluem o comportamento de variação das matrizes, e o tratamento de objetos parametrizados tipo. A partir de 0,3, as matrizes mutáveis e imutáveis são invariantes. Além disso, os argumentos transmitidos a um callable não podem ser parâmetros do tipo. Nestes casos, os argumentos de tipo devem ser transmitidos juntamente com o identificador.

As versões anteriores do compilador Q# permitiram fornecer um valor de função quando se esperava um valor de operação, desde que o valor da função tivesse os tipos de entrada e saída corretos. Este foi um comportamento não intencional que não é especificado na especificação da língua Q#.
No compilador 0.3, removemos este comportamento para que os valores de função deixem de ser considerados valores de funcionamento.
Para minimizar a perturbação do código existente que se baseava neste bug, adicionámos a função ToOperation no espaço de nome Microsoft.Quantum.Canon que converterá explicitamente uma função numa operação com os mesmos tipos de entrada e saída.

O exemplo que se segue ilustra como utilizar a função `ToOperation` para alterar uma função `Square` a uma operação `op`: 
```qsharp
namespace Microsoft.Quantum.Tests {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    function Square(x : Int) : Int {
        return x * x;
    }

    operation ApplyOp<'T, 'U>(op : ('T => 'U), input : 'T) : 'U {
        return op(input);
    }

    operation ToOperationTest() : Unit {
        let op = ToOperation(Square);
        AssertIntEqual(ApplyOp(op, 3), 9, "ToOperation failed with Square.");
    }
}
```

## <a name="requirements"></a>Requisitos 

O lançamento é suportado no Visual Studio 2017 versão 15.8 ou posterior para windows 10, e no Visual Studio Code versão 1.27.2 ou mais tarde para Windows 10, macOS e Linux.

O Kit de Desenvolvimento Quântico utiliza o .NET Core SDK (2.0 ou mais tarde).

## <a name="installation"></a>Instalação  

Siga as instruções de instalação [aqui](../install-guide/index.md).

Pode ver avisos ("Encontrados conflitos entre diferentes versões de "System.Reflection.Metadata" que não poderiam ser resolvidos.") se a sua versão atual de .NET Core SDK não estiver atualizada.  No entanto, se estiver a utilizar o .NET Core SDK (2.0 ou mais tarde), estas advertências podem ser ignoradas.


- O lançamento é fornecido juntamente com uma série de amostras diferentes que mostram como usar ambas as funcionalidades existentes do Kit de Desenvolvimento Quântico, e as novas funcionalidades disponíveis com esta versão. Estas amostras podem ser encontradas no GitHub no repositório [Microsoft/Quantum.](https://github.com/Microsoft/Quantum)


## <a name="Migration"></a>Migração de projetos existentes para o Q#0.3 

Se tiver os projetos Q# existentes a partir da versão 0.2 do Kit de Desenvolvimento Quântico, seguem-se os passos para migrar esses projetos para a versão mais recente. Também fornecemos um [roteiro de migração](#MigrationScript) para ajudá-lo com o processo.

> [!NOTE]
> Os projetos precisam de ser atualizados por ordem. Se tiver uma solução com vários projetos atualizar cada projeto na ordem, são referenciados.


1. Numa linha de comandos, execute `dotnet clean` para remover todos ficheiros intermediários e binários existentes.
2. Num editor de texto, edite o ficheiro .csproj para alterar a versão de todos os `PackageReference` "Microsoft.Quantum" para a versão 0.3.1811.2802-pré-visualização, por exemplo:
```xml
    <PackageReference Include="Microsoft.Quantum.Canon" Version="0.3.1811.2802" />
    <PackageReference Include="Microsoft.Quantum.Development.Kit" Version="0.3.1811.2802" />
```
4. A partir da linha de comando, utilize a ferramenta de formatação integrada no compilador de linha de comando para abordar todas as alterações de sintaxe executando este comando: `dotnet msbuild /t:qsharpformat`  
    - Os seus ficheiros serão migrados no local. Uma cópia de todos os ficheiros originais de todos os ficheiros originais será copiada para `obj\qsharp\.backup`
    - A ferramenta de formatação irá compilar o projeto ignorando todos os erros de compilação e gerando código Q# formado com base na compilação de construção. 
       Qualquer símbolo não reconhecido (por exemplo, um nome variável indefinido) será substituído por um texto do espaço reservado que precisa de ser substituído manualmente após a formatação. Neste caso, a formatação tem sucesso ao mesmo tempo que gera um aviso para o ficheiro afetado.     
    - A formatação e, em particular, qualquer espaço branco no ficheiro serão alterados no código emitido. Os comentários serão preservados.   
5. Depois de executar isto, você ainda pode precisar de abordar manualmente as mudanças semânticas nos casos em que a interpretação semântica do código mudou. Todos estes erros serão relatados pela IntelliSense em Visual Studio ou Visual Studio Code.
    - Abra a pasta raiz do projeto ou a solução contendo no Visual Studio 2017 ou visual Studio Code.
    - Depois de abrir um ficheiro .qs no editor, verá o resultado da extensão de linguagem Q# na janela de resultados.
    - Depois de carregar o projeto com êxito (indicado na janela de resultados), abra cada ficheiro manualmente para resolver todos os problemas restantes.


> [!NOTE]
> * Para o lançamento 0.3, o servidor de idiomas incluído no Kit de Desenvolvimento Quântico não suporta vários espaços de trabalho.
> * Para trabalhar com um projeto no Visual Studio Code, abra a pasta raiz que contém o projeto em si e todos os projetos referenciados.   
> * Para poder trabalhar com uma solução no Visual Studio, todos os projetos contidos na solução têm de estar na mesma pasta que a solução ou numa das suas subpastas.  
> * **Não** são apoiadas referências entre projetos migrados para 0,3 e projetos que utilizem versões de pacotes mais antigas.




## <a name="MigrationScript"></a>Roteiro de migração 

Para facilitar a migração do projeto, é fornecido um script PowerShell que pode ser descarregado [aqui](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1).
Este guião ajuda a migrar projetos da versão 0.2 do Kit de Desenvolvimento Quântico para utilizar a versão 0.3.

> [!NOTE]
> O script de migração requer que o Windows PowerShell ou o PowerShell Core sejam executados.
> O Windows PowerShell vem pré-instalado com o Windows 10.
> Baixe powerShell Core para Windows, macOS ou Linux em https://github.com/PowerShell/PowerShell.

O guião executa os seguintes quatro passos:

- O projeto é construído com a versão anterior do Kit de Desenvolvimento Quântico para garantir que a migração é suscetível de ser bem sucedida. Este passo pode ser ignorado utilizando o parâmetro `-Force` para o script.
- Novos modelos de projeto estão instalados.
- O projeto é atualizado para usar a versão atual do Kit de Desenvolvimento Quântico.
- A ferramenta de formatação fornecida com a versão 0.3 do Kit de Desenvolvimento Quântico é aplicada para abordar automaticamente a maioria das alterações de rutura documentadas acima.

Após estes quatro passos concluídos, pode haver algumas questões de migração restantes que devem ser tratadas manualmente.
Usar a versão mais recente das extensões do Quantum Development Kit para visual studio 2017 e Visual Studio Code pode ajudar a encontrar estes problemas facilmente.

A documentação para o script pode ser obtida executando um dos seguintes comandos na pasta onde o script está localizado:

```powershell
Get-Help ./qdk-migrate.ps1
Get-Help -Online ./qdk-migrate.ps1
```

> [!NOTE]
> Por predefinição, o Windows impede a execução de quaisquer scripts como medida de segurança.
> Para permitir que scripts como `qdk-migrate.ps1` a ser executados no Windows, poderá ter de alterar a política de execução.
> Para isso, dirija o comando `Set-ExecutionPolicy`:
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope Process
> ```
> A política de execução será revertida quando sair da PowerShell.
> Se quiser salvar a política de execução, utilize um valor diferente para `-Scope`:
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
> ```

