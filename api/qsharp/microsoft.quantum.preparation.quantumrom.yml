### YamlMime:QSharpType
uid: microsoft.quantum.preparation.quantumrom
name: QuantumROM
type: function
namespace: Microsoft.Quantum.Preparation
summary: >-
  Usa a técnica de ROM quântica para representar uma determinada matriz de densidade.


  Dada uma lista de coeficientes de $N$alpha_j$, isto devolve um $U unitário que usa a técnica Quantum-ROM para preparar uma aproximação $\tilde\rho\sum_{j=0}^{N-1}p_j\ket{j}\bra{j}$ da purificação da matriz de densidade $\rho=\sum_{j=0}^{N-1}\frac{[alpha_j]} {\sum_k [alpha_k]} \ket{j}\bra{j}$. Nesta aproximação, o erro $\epsilon$ é tal que $[p_j-\frac{[alpha_j]. {\sum_k [\alpha_k]; \le \epsilon / N$ e $\|\tilde\rho - \rho\| \le \epsilon$. Por outras palavras, $$ \begin{align} U\ket{0}^{\lceil\log_2{0}N\rceil}\ket ^{m}=\sum_{j=0}^{N-1}\sqrt{p_j} \ket{j}\ket{\text{trash}_j}.

  \end{align} $$
examples: >-
  O seguinte código snippet prepara uma purificação do estado $3$-qubit $\rho=\sum_{j=0}^{4}\frac{[alpha_j]} {\sum_k [alpha_k]} \ket{j}\bra{j}$, onde $\vec\alfa=(1.0,2.0,0,0.0.0,5.0)$, e `1e-3`o erro é;


  ```qsharp

  let coefficients = [1.0,2.0,3.0,4.0,5.0];

  let targetError = 1e-3;

  let ((nTotalQubits, (nIndexQubits, nGarbageQubits)), oneNorm, op) = QuantumROM(targetError, coefficients);

  using (indexRegister = Qubit[nIndexQubits]) {
      using (garbageRegister = Qubit[nGarbageQubits]) {
          op(LittleEndian(indexRegister), garbageRegister);
      }
  }

  ```
syntax: 'function QuantumROM (targetError : Double, coefficients : Double[]) : ((Int, (Int, Int)), Double, ((Microsoft.Quantum.Arithmetic.LittleEndian, Qubit[]) => Unit is Adj + Ctl))'
references: '- Codificação de Espectros Eletrônicos em Circuitos Quânticos com Complexidade Linear T Ryan Babbush, Craig Gidney, Dominic W. Berry, Nathan Wiebe, Jarrod McClean, Alexandru Paler, Austin Fowler, Hartmut Nevenhttps://arxiv.org/abs/1805.03662'
input:
  content: '(targetError : Double, coefficients : Double[])'
  types:
  - name: targetError
    summary: O erro do alvo $\epsilon$.
    isPrimitive: true
    uid: Double
  - name: coefficients
    summary: >-
      Uma série de coeficientes de $N$ que especificam a probabilidade de estados de base.

      Os números negativos $-\alpha_j$ serão tratados como positivos $alpha_j[$].
    isArray: true
    isPrimitive: true
    uid: Double
output:
  content: ((Int, (Int, Int)), Double, ((Microsoft.Quantum.Arithmetic.LittleEndian, Qubit[]) => Unit is Adj + Ctl))
  types:
  - summary: >-
      ## <a name="first-parameter"></a>Primeiro parâmetro


      `(x,(y,z))` Uma tuple `x = y + z` onde está o número total `y` de qubits atribuídos, `LittleEndian` é `z` o número de qubits para o registo, e é o Número de qubits de lixo.


      ## <a name="second-parameter"></a>Segundo parâmetro


      A norma única $\sum_j [\alpha_j[$ da matriz de coeficiente.


      ## <a name="third-parameter"></a>Terceiro parâmetro


      O unitário $U$.
    types:
    - types:
      - isPrimitive: true
        uid: Int
      - types:
        - isPrimitive: true
          uid: Int
        - isPrimitive: true
          uid: Int
    - isPrimitive: true
      uid: Double
    - isOperation: true
      input:
        types:
        - uid: microsoft.quantum.arithmetic.littleendian
        - isArray: true
          isPrimitive: true
          uid: Qubit
      output:
        types:
        - isPrimitive: true
          uid: Unit
      functors:
      - Adjoint
      - Controlled
metadata:
  ms.openlocfilehash: 9bf373f0cb7c495f8c29a4426861c74fbb0ec7f6
  ms.sourcegitcommit: db23885adb7ff76cbf8bd1160d401a4f0471e549
  ms.translationtype: MT
  ms.contentlocale: pt-PT
  ms.lasthandoff: 05/01/2020
  ms.locfileid: "82686484"
